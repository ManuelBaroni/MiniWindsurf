<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Windsurf Adventure Fullscreen Corrected</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #000033;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
        }
        #controlsInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.65);
            padding: 5px;
            border-radius: 3px;
            z-index: 100;
            max-width: calc(100% - 20px);
            box-sizing: border-box;
        }
        #fullscreenButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            font-size: 14px;
            background-color: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.5);
            color: white;
            cursor: pointer;
            border-radius: 5px;
            z-index: 101;
        }
    </style>
</head>
<body>
    <button id="fullscreenButton">Fullscreen</button>
    <div id="controlsInfo"></div>
    <script>
        // --- CONFIGURAZIONI ---
        const WORLD_WIDTH = 12000;
        const WORLD_HEIGHT = 9000;
        const NUM_OCEAN_PARTICLES = 400;
        const SHOW_DEBUG_INFO = false;

        // --- VARIABILI GLOBALI ---
        let windsurf;
        let wind;
        let oceanParticles = [];
        let islands = [];
        let camera;
        let P5_TWO_PI;
        let fullscreenBtn;

        let touchState = {
            steer: { active: false, startX: 0, id: -1 },
            efficiency: { active: false, startY: 0, id: -1 } // Per controllo efficienza vela
        };

        // --- CLASSE CAMERA ---
        class Camera {
            constructor(x, y, followStrength = 0.08) {
                this.pos = createVector(x, y);
                this.target = null;
                this.followStrength = followStrength;
            }
            follow(target) { this.target = target; }
            update() {
                if (this.target) {
                    let effectiveDeltaTime = deltaTime / 16.66;
                    let targetX = this.target.pos.x - width / 2;
                    let targetY = this.target.pos.y - height / 2;
                    this.pos.x += (targetX - this.pos.x) * this.followStrength * effectiveDeltaTime;
                    this.pos.y += (targetY - this.pos.y) * this.followStrength * effectiveDeltaTime;
                    this.pos.x = constrain(this.pos.x, 0, WORLD_WIDTH - width);
                    this.pos.y = constrain(this.pos.y, 0, WORLD_HEIGHT - height);
                }
            }
            apply() { translate(-this.pos.x, -this.pos.y); }
        }
                // --- CLASSE WINDSURF (LOGICA POSIZIONAMENTO VELA E CONTROVENTO MIGLIORATA) ---
        class Windsurf {
            constructor(x, y) {
                this.pos = createVector(x, y);
                this.vel = createVector(0, 0);
                this.angle = -P5_TWO_PI / 4; // Angolo della tavola

                this.currentSailAngle = 0;    // Angolo RELATIVO della "base" vela rispetto alla tavola
                this.targetSailAngle = 0;
                this.sailRotationSpeed = P5_TWO_PI * 0.45; 

                this.boardWidth = 22;
                this.boardLength = 80;
                this.sailBaseLength = 60; 
                this.maxSailArchDepth = this.sailBaseLength * 0.35; 
                this.currentSailArchDepth = 0;

                this.mastAttachmentPointX = -this.boardLength * 0.10;

                this.maxSpeed = 7;
                this.turnRate = 0.04;
                this.friction = 0.02;
                this.lateralResistance = 0.92;
                this.baseAccelerationFactor = 0.08;
                this.isColliding = false;

                this.sailEfficiencyModifier = 0;
                this.sailEfficiencyChangeRate = 0.03;
            }

            handleInput() { /* ... identico alla versione precedente ... */ }
            turn(direction, dt) { /* ... identico ... */ }

            // Questa funzione calcola la forza propulsiva data la configurazione
            calculatePropulsionForRelativeSail(boardAngle, relativeSailAngle, currentWindAngle, currentWindStrength) {
                let sailGlobalAngle = boardAngle + relativeSailAngle; // Angolo globale del "boma"
                
                // Angolo tra il vento e la NORMALE della vela.
                // La normale è dove la vela "cattura" meglio il vento, perpendicolare al boma.
                let windToSailNormalAngle = smallestAngleBetween(currentWindAngle, sailGlobalAngle + P5_TWO_PI / 4);
                let forceMagnitudeOnSail = currentWindStrength * cos(windToSailNormalAngle);
                
                // La forza propulsiva agisce lungo la direzione della tavola.
                // La forza generata dalla vela è perpendicolare al boma.
                let forceDirFromSail = sailGlobalAngle + P5_TWO_PI / 4;
                let angleBetweenForceAndBoard = smallestAngleBetween(forceDirFromSail, boardAngle);
                
                let propulsion = forceMagnitudeOnSail * cos(angleBetweenForceAndBoard);
                return propulsion;
            }
            
            // Questa è la funzione chiave per il posizionamento della vela
            calculateOptimalRelativeSailAngle(boardAngle, currentWindAngle, currentWindStrength) {
                let windAngleRelativeToBoard = smallestAngleBetween(currentWindAngle, boardAngle);
                // windAngleRelativeToBoard:
                // 0: vento da prua
                // PI/2: vento da dritta (90 gradi a destra della prua)
                // PI: vento da poppa
                // -PI/2: vento da sinistra (90 gradi a sinistra della prua)

                let optimalRelativeSailAngle = 0;

                // 1. Caso: Prua al vento (o quasi) - "Zona Morta"
                const deadZoneAngle = P5_TWO_PI * 0.12; // ~43 gradi (2 * 0.12 * 180/PI)
                if (abs(windAngleRelativeToBoard) < deadZoneAngle) {
                    // Vela "in bandiera", allineata con il vento, ma relativa alla tavola.
                    // L'idea è che la vela si allinei con il vento, quindi il suo angolo globale
                    // dovrebbe essere wind.angle.
                    // sailGlobal = boardAngle + optimalRelativeSailAngle
                    // optimalRelativeSailAngle = wind.angle - boardAngle
                    optimalRelativeSailAngle = smallestAngleBetween(currentWindAngle, boardAngle);
                    // E dovrebbe essere "dietro" l'albero (punto di attacco).
                    // Se wind.angle - boardAngle è piccolo, la vela è quasi parallela alla tavola.
                    // Per farla andare "dietro", la forziamo verso angoli grandi (vicino a PI o -PI relativo)
                    // ma questo non è corretto per il luffing.
                    // Nel luffing, la vela si allinea semplicemente con il vento.
                    // L'angolo relativo sarà quindi l'opposto dell'angolo del vento relativo alla tavola.
                    optimalRelativeSailAngle = -windAngleRelativeToBoard; // La vela si allinea con il vento
                    // Se il vento è da prua (windAngleRelBoard ~ 0), optimalRelSail ~ 0 (vela al centro)
                    // Se il vento è leggermente da dx (windAngleRelBoard ~ +0.1), optimalRelSail ~ -0.1 (vela leggermente a dx)
                    // Questo la fa sbattere. Per la grafica "dietro", la faremo ruotare di PI.
                    // Ma per la fisica, questo è più corretto per il luffing.
                    // Per la visualizzazione "dietro" come nell'immagine "Prua al vento",
                    // si potrebbe forzare l'angolo a 0 e la pancia a 0 o negativa.
                    // Per ora, ci concentriamo sull'angolo che genera meno forza.
                }
                // 2. Caso: Poppa (vento da dietro)
                else if (abs(abs(windAngleRelativeToBoard) - PI) < P5_TWO_PI * 0.20) { // ~72 gradi di settore di poppa
                    // Vento da poppa: vela perpendicolare alla tavola.
                    // Se il vento è da dritta della poppa (windAngleRelBoard > PI/2 e < 3PI/2, cioè positivo e grande)
                    // allora la vela dovrebbe stare a sinistra (+PI/2).
                    // Se il vento è da sinistra della poppa (windAngleRelBoard < -PI/2 e > -3PI/2, cioè negativo e grande)
                    // allora la vela dovrebbe stare a dritta (-PI/2).
                    // Questa logica è un po' contorta. Più semplice:
                    if (windAngleRelativeToBoard > 0) { // Vento viene da dritta (rispetto alla prua) o dritta-poppa
                        optimalRelativeSailAngle = P5_TWO_PI / 4;  // Vela a sinistra (+90 gradi)
                    } else { // Vento viene da sinistra (rispetto alla prua) o sinistra-poppa
                        optimalRelativeSailAngle = -P5_TWO_PI / 4; // Vela a dritta (-90 gradi)
                    }
                }
                // 3. Casi Intermedi (Bolina, Traverso, Lasco)
                else {
                    // Logica di ottimizzazione generale: trova l'angolo che massimizza la propulsione.
                    // Questa logica dovrebbe già tendere a mettere la vela sul lato corretto.
                    let bestAngleFound = 0;
                    let maxPropulsion = -Infinity;
                    // Limitiamo il test degli angoli a un range più realistico per le andature portanti
                    // o cerchiamo su tutto il range e poi lo aggiustiamo?
                    // L'immagine suggerisce che la vela non supera mai i +/- 90 gradi relativi.
                    
                    // Mure a dritta: vento da dritta (0 < windAngleRelBoard < PI). Vela va a sinistra (optimalRelSail > 0).
                    // Mure a sinistra: vento da sinistra (0 > windAngleRelBoard > -PI). Vela va a dritta (optimalRelSail < 0).

                    let searchStart = 0;
                    let searchEnd = 0;
                    let searchStep = P5_TWO_PI / 72; // ~5 gradi

                    if (windAngleRelativeToBoard > 0) { // Vento da dritta, la vela dovrebbe andare a sinistra
                        searchStart = 0.05; // Evita 0
                        searchEnd = P5_TWO_PI / 4 + 0.1; // Poco oltre 90 gradi a sinistra
                    } else { // Vento da sinistra, la vela dovrebbe andare a dritta
                        searchStart = -P5_TWO_PI / 4 - 0.1; // Poco oltre 90 gradi a dritta
                        searchEnd = -0.05; // Evita 0
                    }
                    
                    // Se l'iterazione precedente non trova una buona soluzione, potremmo dover ampliare
                    // la ricerca o usare un approccio più analitico.
                    // Per ora, la ricerca completa e poi la selezione del lato sembra più robusta.
                    let tempBestAngle = 0;
                    let tempMaxProp = -Infinity;

                    for (let testRelAngle = -P5_TWO_PI / 2 + 0.01; testRelAngle < P5_TWO_PI / 2 - 0.01; testRelAngle += searchStep) {
                         let prop = this.calculatePropulsionForRelativeSail(boardAngle, testRelAngle, currentWindAngle, currentWindStrength);
                         if (prop > tempMaxProp) {
                             tempMaxProp = prop;
                             tempBestAngle = testRelAngle;
                         }
                    }
                    optimalRelativeSailAngle = tempBestAngle;

                    // Assicura che la vela sia sul lato corretto (sottovento rispetto alla tavola)
                    // Questa è la parte più delicata per replicare l'immagine.
                    // Se vento da dritta (windAngleRel > 0), vela a sinistra (optimalRel > 0)
                    // Se vento da sinistra (windAngleRel < 0), vela a dritta (optimalRel < 0)
                    if (windAngleRelativeToBoard > deadZoneAngle && optimalRelativeSailAngle < 0) {
                        // Vento da dritta, ma l'ottimizzazione ha messo la vela a dritta. Errore.
                        // Forse la vela dovrebbe essere specchiata o ricalcolata sull'altro lato.
                        // Per ora, ci fidiamo che l'ottimizzazione trovi il lato corretto se il range è ampio.
                        // La logica precedente (testare tutti gli angoli da -PI/2 a PI/2) è più probabile che funzioni.
                    } else if (windAngleRelativeToBoard < -deadZoneAngle && optimalRelativeSailAngle > 0) {
                        // Vento da sinistra, ma ottimizzazione ha messo vela a sinistra. Errore.
                    }
                }
                return constrain(optimalRelativeSailAngle, -P5_TWO_PI/2 * 0.98, P5_TWO_PI/2 * 0.98); // Limita a poco meno di +/- 90gradi
            }


            update() {
                let effectiveDeltaTime = deltaTime / 16.66;

                this.targetSailAngle = this.calculateOptimalRelativeSailAngle(this.angle, wind.angle, wind.strength);
                // ... (interpolazione currentSailAngle verso targetSailAngle - IDENTICA)
                let angleDiff = smallestAngleBetween(this.targetSailAngle, this.currentSailAngle);
                let maxRotationThisFrame = this.sailRotationSpeed * (deltaTime / 1000); 
                if (abs(angleDiff) <= maxRotationThisFrame) { this.currentSailAngle = this.targetSailAngle; }
                else { this.currentSailAngle += Math.sign(angleDiff) * maxRotationThisFrame; }
                this.currentSailAngle = (this.currentSailAngle % P5_TWO_PI + P5_TWO_PI) % P5_TWO_PI;
                if (this.currentSailAngle > P5_TWO_PI / 2) this.currentSailAngle -= P5_TWO_PI;


                // Calcolo della "pancia" dell'arco
                let sailGlobalAngle = this.angle + this.currentSailAngle;
                let windToSailAxisNormal = smallestAngleBetween(wind.angle, sailGlobalAngle + P5_TWO_PI / 4);
                let pressureFactor = cos(windToSailAxisNormal); 
                pressureFactor = max(0, pressureFactor);

                // Caso speciale: prua al vento -> vela sgonfia o sbatte
                let windAngleRelativeToBoard = smallestAngleBetween(wind.angle, this.angle);
                const deadZoneAngle = P5_TWO_PI * 0.12;
                if (abs(windAngleRelativeToBoard) < deadZoneAngle) {
                    pressureFactor = 0.05; // Minima pancia, o sbatte (animazione futura)
                }

                let targetSailArchDepth = this.maxSailArchDepth * pressureFactor * (wind.strength / 1.5);
                targetSailArchDepth = constrain(targetSailArchDepth, 0, this.maxSailArchDepth);
                this.currentSailArchDepth += (targetSailArchDepth - this.currentSailArchDepth) * 0.20 * effectiveDeltaTime;


                // Calcolo Propulsione
                let rawSailPropulsion = this.calculatePropulsionForRelativeSail(this.angle, this.currentSailAngle, wind.angle, wind.strength);
                
                // Se prua al vento, la propulsione dovrebbe essere molto bassa o negativa
                if (abs(windAngleRelativeToBoard) < deadZoneAngle) {
                    rawSailPropulsion = min(0, rawSailPropulsion); // Non spingere avanti se controvento
                    // Potremmo anche aggiungere una piccola forza all'indietro se la vela "prende al contrario"
                    if (cos(windAngleRelativeToBoard) > 0.95) { // Vento quasi perfettamente da prua
                        rawSailPropulsion -= 0.01 * wind.strength; // Piccola spinta indietro
                    }
                }

                let effectiveAccelerationFactor = this.baseAccelerationFactor * (1 + this.sailEfficiencyModifier);
                effectiveAccelerationFactor = max(0, effectiveAccelerationFactor);
                let finalPropulsion = rawSailPropulsion;
                let boardDirection = p5.Vector.fromAngle(this.angle);
                let sailAcceleration = boardDirection.copy().mult(finalPropulsion * effectiveAccelerationFactor);
                this.vel.add(p5.Vector.mult(sailAcceleration, effectiveDeltaTime));

                // ... (resto di update: Attrito, Resistenza Laterale, ecc. IDENTICO) ...
                let frictionForce = this.vel.copy().mult(-this.friction);
                this.vel.add(p5.Vector.mult(frictionForce, effectiveDeltaTime));
                let perpendicularToBoard = p5.Vector.fromAngle(this.angle + P5_TWO_PI / 4);
                let lateralVelocityComponent = p5.Vector.dot(this.vel, perpendicularToBoard);
                let lateralDragForce = perpendicularToBoard.copy().mult(-lateralVelocityComponent * this.lateralResistance);
                this.vel.add(p5.Vector.mult(lateralDragForce, effectiveDeltaTime));
                if (this.vel.mag() > this.maxSpeed) this.vel.setMag(this.maxSpeed);
                 // Se quasi fermo e controvento, ferma del tutto
                if (abs(windAngleRelativeToBoard) < deadZoneAngle && this.vel.mag() < 0.05) {
                    this.vel.set(0,0);
                }
                if (!this.isColliding) { this.pos.add(p5.Vector.mult(this.vel, effectiveDeltaTime)); }
                else { this.vel.mult(0.3); }
                this.isColliding = false;
                if (this.pos.x < this.boardLength / 2) { this.pos.x = this.boardLength / 2; this.vel.x *= -0.3; }
                if (this.pos.x > WORLD_WIDTH - this.boardLength / 2) { this.pos.x = WORLD_WIDTH - this.boardLength / 2; this.vel.x *= -0.3; }
                if (this.pos.y < this.boardLength / 2) { this.pos.y = this.boardLength / 2; this.vel.y *= -0.3; }
                if (this.pos.y > WORLD_HEIGHT - this.boardLength / 2) { this.pos.y = WORLD_HEIGHT - this.boardLength / 2; this.vel.y *= -0.3; }
            }

            checkCollision(island) { /* ... identico ... */ }
            draw() { /* ... identico alla versione precedente con l'arco ... */ } // Il disegno dell'arco dovrebbe già essere corretto
            getSpeed() { return this.vel.mag(); }
        }
        
        // --- CLASSE WINDSURF ---
        
        // --- CLASSE ISOLA ---
        class Island { 
            constructor(x, y, size, seed) {
                this.pos = createVector(x, y); this.size = size; this.seed = seed || random(10000);
                this.polygons = [];
                this.color = color(random(100,140), random(150,190), random(60,100));
                this.beachColor = color(random(210,240), random(190,220), random(150,180));
                this.generateShape();
            }
            generateShape() {
                let islandVerts = []; let numVertices = int(random(7, 15)); noiseSeed(this.seed);
                for (let i = 0; i < numVertices; i++) {
                    let angle = map(i, 0, numVertices, 0, P5_TWO_PI);
                    let r = this.size * (0.6 + 0.8 * noise(cos(angle) * 2 + 10, sin(angle) * 2 + 20, this.seed * 0.01));
                    islandVerts.push(createVector(this.pos.x + r * cos(angle), this.pos.y + r * sin(angle)));
                }
                this.polygons.push(islandVerts);
            }
            draw() {
                for (const polygon of this.polygons) {
                    strokeWeight(this.size * 0.20); stroke(this.beachColor); noFill();
                    beginShape(); for (let v of polygon) curveVertex(v.x, v.y);
                    if (polygon.length > 2) { curveVertex(polygon[0].x, polygon[0].y); curveVertex(polygon[1].x, polygon[1].y); curveVertex(polygon[2].x, polygon[2].y); }
                    endShape();
                    fill(this.color); noStroke();
                    beginShape(); for (let v of polygon) vertex(v.x, v.y); endShape(CLOSE);
                    if (this.size > 100) {
                        for(let i=0; i< polygon.length; i+=2) {
                            if(random() < 0.3) {
                                let v = polygon[i];
                                let treeOffsetX = (noise(v.x*0.1, v.y*0.1, this.seed+100)-0.5) * this.size * 0.2;
                                let treeOffsetY = (noise(v.x*0.1, v.y*0.1, this.seed+200)-0.5) * this.size * 0.2;
                                let treeX = v.x + treeOffsetX; let treeY = v.y + treeOffsetY;
                                if (collidePointPoly(treeX, treeY, polygon)) {
                                    fill(50, random(80,120), 30); ellipse(treeX, treeY, this.size*0.08, this.size*0.12);
                                    fill(80,60,40); rect(treeX-this.size*0.01, treeY+this.size*0.05, this.size*0.02, this.size*0.05);
                                } } } } } }
        }

        function updateWind() {
             if (!wind) return;
            let effectiveDeltaTime = deltaTime / 16.66;
            let da = smallestAngleBetween(wind.targetAngle, wind.angle);
            wind.angle += da * wind.variability * effectiveDeltaTime; 
            wind.angle = (wind.angle % P5_TWO_PI + P5_TWO_PI) % P5_TWO_PI;
            
            if (abs(da) < 0.01 || random(1) < 0.0005 * effectiveDeltaTime) {
                 wind.targetAngle = wind.angle + random(-P5_TWO_PI/5, P5_TWO_PI/5);
                 wind.targetAngle = (wind.targetAngle % P5_TWO_PI + P5_TWO_PI) % P5_TWO_PI;
            }
            let ds = wind.targetStrength - wind.strength;
            wind.strength += ds * wind.strengthVariability * effectiveDeltaTime;
            if (abs(ds) < 0.05 || random(1) < 0.001 * effectiveDeltaTime) {
                wind.targetStrength = constrain(random(0.7, 3.2), 0.5, 3.5);
            }
        }
        function smallestAngleBetween(target, source) {
            let a = (target - source) % P5_TWO_PI;
            return a > P5_TWO_PI / 2 ? a - P5_TWO_PI : (a < -P5_TWO_PI / 2 ? a + P5_TWO_PI : a);
        }
        function getClosestPointOnSegment(p, a, b) {
            let ap = p5.Vector.sub(p, a); let ab = p5.Vector.sub(b, a);
            let abMagSq = ab.magSq(); if (abMagSq === 0) return a.copy();
            let t = constrain(p5.Vector.dot(ap, ab) / abMagSq, 0, 1);
            return p5.Vector.add(a, ab.mult(t));
        }
        function collidePointPoly(px, py, vertices) {
            var collision = false; var next = 0;
            for (var current = 0; current < vertices.length; current++) {
                next = current + 1; if (next == vertices.length) next = 0;
                var vc = vertices[current]; var vn = vertices[next];
                if (((vc.y > py && vn.y < py) || (vc.y < py && vn.y > py)) &&
                    (px < (vn.x - vc.x) * (py - vc.y) / (vn.y - vc.y) + vc.x)) {
                    collision = !collision;
                }
            }
            return collision;
        }

       function setup() {
            let canvas = createCanvas(windowWidth, windowHeight); // Coerente con windowResized
            canvas.parent(document.body);
            pixelDensity(1);
            
            P5_TWO_PI = TWO_PI;
            if (typeof P5_TWO_PI === 'undefined') P5_TWO_PI = 2 * Math.PI;

            wind = { angle: random(P5_TWO_PI), strength: 1.5, targetAngle: random(P5_TWO_PI), targetStrength: 1.5, variability: 0.001, strengthVariability: 0.0005 };
            windsurf = new Windsurf(WORLD_WIDTH / 2, WORLD_HEIGHT / 2);
            camera = new Camera(windsurf.pos.x - width/2, windsurf.pos.y - height/2); camera.follow(windsurf);
            let numIslands = 60;
            for (let i = 0; i < numIslands; i++) {
                let islandX = random(WORLD_WIDTH * 0.02, WORLD_WIDTH * 0.98); let islandY = random(WORLD_HEIGHT * 0.02, WORLD_HEIGHT * 0.98);
                let islandSize = random(120, 600);
                if (dist(islandX, islandY, windsurf.pos.x, windsurf.pos.y) > max(islandSize, 300) + 300) { islands.push(new Island(islandX, islandY, islandSize, i * 123.456)); } else { i--; }
            }
            for (let i = 0; i < NUM_OCEAN_PARTICLES; i++) { oceanParticles.push({ x: random(WORLD_WIDTH), y: random(WORLD_HEIGHT), size: random(0.5, 2.5), opacity: random(15, 50), speedFactor: random(0.05, 0.25) }); }
            
            updateWind();
            updateControlsInfo();

            fullscreenBtn = document.getElementById('fullscreenButton');
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', toggleFullScreen);
                if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled && !document.mozFullScreenEnabled && !document.msFullscreenEnabled) {
                    fullscreenBtn.style.display = 'none';
                }
            }
            windowResized(); // Chiamata iniziale per assicurare dimensioni corrette
        }
        function toggleFullScreen() {
            let elem = document.documentElement;
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                if (elem.requestFullscreen) elem.requestFullscreen();
                else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
                else if (elem.mozRequestFullScreen) elem.mozRequestFullScreen();
                else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
            }
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight); // Coerente con setup
            updateControlsInfo();
            if (camera) {
                 camera.pos.x = constrain(camera.pos.x, 0, WORLD_WIDTH - width);
                 camera.pos.y = constrain(camera.pos.y, 0, WORLD_HEIGHT - height);
            }
        }

        document.addEventListener('fullscreenchange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.fullscreenElement ? "Exit" : "Fullscreen"; });
        document.addEventListener('webkitfullscreenchange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.webkitFullscreenElement ? "Exit" : "Fullscreen"; });
        document.addEventListener('mozfullscreenchange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.mozFullScreenElement ? "Exit" : "Fullscreen"; });
        document.addEventListener('MSFullscreenChange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.msFullscreenElement ? "Exit" : "Fullscreen"; });
        
        function draw() {
            if (!wind || !windsurf) { background(0); fill(255); textSize(20); textAlign(CENTER,CENTER); text("Loading...", width/2, height/2); return; }
            background(30, 60, 130);
            windsurf.handleInput(); handleTouchControls(); // handleTouchControls ora gestisce efficienza
            updateWind(); windsurf.update(); camera.update();
            for (let island of islands) { if (dist(windsurf.pos.x, windsurf.pos.y, island.pos.x, island.pos.y) < island.size + windsurf.boardLength * 1.5) windsurf.checkCollision(island); }
            push(); camera.apply(); drawOceanSurface();
            for (let island of islands) { if (island.pos.x + island.size > camera.pos.x && island.pos.x - island.size < camera.pos.x + width && island.pos.y + island.size > camera.pos.y && island.pos.y - island.size < camera.pos.y + height) island.draw(); }
            windsurf.draw(); pop();
            drawWindIndicator(); drawSpeedometer(); drawSailAngleIndicator(); drawMiniMap();
            if (SHOW_DEBUG_INFO) drawDebugInfo();
        }

        let waveOffset = 0;
        function drawOceanSurface() {
            stroke(180, 200, 230); let effectiveDeltaTime = deltaTime / 16.66;
            for (let p of oceanParticles) {
                strokeWeight(p.size); fill(180,200,230, p.opacity);
                p.x += cos(wind.angle) * wind.strength * p.speedFactor * 0.1 * effectiveDeltaTime;
                p.y += sin(wind.angle) * wind.strength * p.speedFactor * 0.1 * effectiveDeltaTime;
                p.x = (p.x % WORLD_WIDTH + WORLD_WIDTH) % WORLD_WIDTH; p.y = (p.y % WORLD_HEIGHT + WORLD_HEIGHT) % WORLD_HEIGHT;
                if (p.x > camera.pos.x - 10 && p.x < camera.pos.x + width + 10 && p.y > camera.pos.y - 10 && p.y < camera.pos.y + height + 10) ellipse(p.x, p.y, p.size, p.size);
            }
            let waveDetail = 30; let numWaves = ceil(max(width, height) / waveDetail) + 10; waveOffset += wind.strength * 0.03 * effectiveDeltaTime;
            strokeWeight(1 + wind.strength * 0.3); noFill(); let waveAngle = wind.angle + P5_TWO_PI/4;
            let screenCenterXWorld = camera.pos.x + width/2; let screenCenterYWorld = camera.pos.y + height/2;
            for (let i = -numWaves / 2; i < numWaves / 2; i++) {
                stroke(130, 160, 220, 40 + wind.strength * 15 + sin(i*0.3 + waveOffset*2)*15);
                let lineBaseDist = i * waveDetail + (waveOffset*20 % waveDetail);
                let x0 = screenCenterXWorld + cos(waveAngle) * lineBaseDist - sin(waveAngle) * (width*1.5); let y0 = screenCenterYWorld + sin(waveAngle) * lineBaseDist + cos(waveAngle) * (width*1.5);
                let x1 = screenCenterXWorld + cos(waveAngle) * lineBaseDist + sin(waveAngle) * (width*1.5); let y1 = screenCenterYWorld + sin(waveAngle) * lineBaseDist - cos(waveAngle) * (width*1.5);
                beginShape(); let segments = 30;
                for(let j=0; j<=segments; j++) {
                    let t = j/segments; let x = lerp(x0, x1, t); let y = lerp(y0, y1, t);
                    let noiseX = (x * cos(wind.angle) + y * sin(wind.angle)) * 0.015; let noiseY = (-x * sin(wind.angle) + y * cos(wind.angle)) * 0.008;
                    let noiseVal = noise(noiseX + waveOffset * 0.3, noiseY + i * 0.1);
                    let amplitude = (5 + wind.strength * 3) * (0.5 + noiseVal * 1.5);
                    let vx = x + sin(waveAngle) * amplitude; let vy = y - cos(waveAngle) * amplitude; curveVertex(vx, vy);
                } endShape(); }
        }
        
        function drawWindIndicator() {
            const isSmallScreen = min(width, height) < 600;
            let R = min(width, height) * (isSmallScreen ? 0.065 : 0.045);
            let margin = min(width, height) * (isSmallScreen ? 0.04 : 0.025);
            let cx = width - R - margin; let cy = R + margin;
            push(); translate(cx, cy); fill(255, 255, 255, 90); noStroke(); ellipse(0,0, R*2, R*2);
            stroke(255,255,255,120); strokeWeight(max(1.2, R*0.025));
            for(let a=0; a<P5_TWO_PI; a+=P5_TWO_PI/16) line(0,0, cos(a)*R, sin(a)*R);
            line(0,-R,0,R); line(-R,0,R,0); rotate(wind.angle);
            let arrowLen = R * 0.8 + wind.strength * (R * 0.08);
            stroke(255,50,50); strokeWeight(max(2, R*0.08 + wind.strength * 0.6)); line(0,0, arrowLen,0);
            fill(255,50,50); noStroke(); triangle(arrowLen,0, arrowLen-R*0.25,-R*0.12, arrowLen-R*0.25,R*0.12); pop();
            fill(255); textSize(max(10, R*0.35)); textAlign(CENTER,CENTER);
            text(wind.strength.toFixed(1) + " kn", cx, cy + R + margin*0.6); text("VENTO", cx, cy - R - margin*0.6);
        }

        function drawSpeedometer() {
            const isSmallScreen = min(width, height) < 600;
            let R = min(width, height) * (isSmallScreen ? 0.075 : 0.055);
            let margin = min(width, height) * (isSmallScreen ? 0.04 : 0.025);
            let cx = R + margin; let cy = height - R - margin;
            push(); translate(cx, cy); noFill(); stroke(255,255,255,120); strokeWeight(max(4, R*0.22));
            arc(0,0, R*2, R*2, P5_TWO_PI * 0.375, P5_TWO_PI * 0.125);
            let speed = windsurf.getSpeed();
            let speedAngle = map(speed, 0, windsurf.maxSpeed, P5_TWO_PI * 0.375, P5_TWO_PI * 0.125);
            stroke(120,220,255); strokeWeight(max(3, R*0.18));
            arc(0,0, R*2, R*2, P5_TWO_PI * 0.375, speedAngle);
            rotate(speedAngle); stroke(255); strokeWeight(max(1.5, R*0.06)); line(0,0,R*0.9,0); pop();
            fill(255); textSize(max(12, R*0.4)); textAlign(CENTER,CENTER);
            text(speed.toFixed(1), cx, cy); textSize(max(9, R*0.28)); text("m/s", cx, cy + R*0.5 + margin*0.4);
        }

        function drawSailAngleIndicator() {
            const isSmallScreen = min(width, height) < 600;
            let ROuterSpeedo = min(width, height) * (isSmallScreen ? 0.075 : 0.055);
            let marginSpeedo = min(width, height) * (isSmallScreen ? 0.04 : 0.025);
            let speedoTopY = height - ROuterSpeedo - marginSpeedo - ROuterSpeedo;
            let R = min(width, height) * (isSmallScreen ? 0.055 : 0.04);
            let margin = min(width, height) * (isSmallScreen ? 0.03 : 0.020);
            let cx = ROuterSpeedo + marginSpeedo; let cy = speedoTopY - R - margin;
            push(); translate(cx, cy); fill(200,170,110,120); noStroke();
            rect(-R*0.2, -R*0.8, R*0.4, R*1.6, R*0.12);
            rotate(windsurf.currentSailAngle); // Usa currentSailAngle
            fill(230,230,250,180); stroke(50); strokeWeight(max(1.2, R*0.05));
            beginShape(); vertex(0,0); vertex(R*1.2, R*0.2); vertex(R*1.1, -R*0.2); endShape(CLOSE); pop();
            fill(255); textSize(max(9, R*0.28)); textAlign(CENTER,CENTER);
            text("VELA", cx, cy + R + margin*0.6);
        }

        function drawMiniMap() {
            const isSmallScreen = min(width, height) < 600;
            let mapSize = min(width, height) * (isSmallScreen ? 0.22 : 0.16);
            let margin = min(width, height) * (isSmallScreen ? 0.035 : 0.025);
            let mapX, mapY;
            if (isSmallScreen) {
                let windIndicatorRadius = min(width, height) * 0.065;
                let windIndicatorMargin = min(width, height) * 0.04;
                let windIndicatorBottom = windIndicatorRadius * 2 + windIndicatorMargin * 2;
                mapX = margin; mapY = windIndicatorBottom + margin;
                if (mapY + mapSize > height - margin) mapY = margin;
            } else {
                mapX = width - mapSize - margin; mapY = height - mapSize - margin;
            }
            let sX = mapSize / WORLD_WIDTH; let sY = mapSize / WORLD_HEIGHT;
            push(); translate(mapX, mapY);
            fill(0, 40, 90, 150); noStroke(); rect(0,0, mapSize, mapSize, max(3, mapSize*0.04));
            for (let island of islands) { fill(island.color); beginShape(); for (let v of island.polygons[0]) vertex(v.x * sX, v.y * sY); endShape(CLOSE); }
            fill(255,0,0); ellipse(windsurf.pos.x*sX, windsurf.pos.y*sY, max(2.5, mapSize*0.02), max(2.5, mapSize*0.02));
            noFill(); stroke(255,255,255,100); strokeWeight(max(1.2, mapSize*0.006));
            rect(camera.pos.x*sX, camera.pos.y*sY, width*sX, height*sY); pop();
        }
        
        function updateControlsInfo() {
            let info = "<b>Controlli Tastiera:</b><br>";
            info += "FRECCE Sx/Dx: Vira<br>";
            info += "FRECCIA SU / W: Aumenta Efficienza Vela<br>";
            info += "FRECCIA GIU / S: Riduci Efficienza Vela<br><br>";
            let controlDiv = document.getElementById('controlsInfo');
            if (isTouchDevice()) {
                info += "<b>Controlli Touch:</b><br>";
                info += "Trascina Metà Sx: Vira<br>";
                info += "Trascina Metà Dx (Vert.): Efficienza Vela"; // Aggiornato
                controlDiv.style.fontSize = "10px";
                controlDiv.style.padding = "3px";
            } else {
                controlDiv.style.fontSize = "12px";
                controlDiv.style.padding = "5px";
            }
            controlDiv.innerHTML = info;
        }
        
        function drawDebugInfo() {
             fill(255);textSize(12);textAlign(LEFT,TOP); let y = 10; const dy = 15;
            text(`Pos: ${windsurf.pos.x.toFixed(0)}, ${windsurf.pos.y.toFixed(0)}`, 10, y); y+=dy;
            text(`Vel: ${windsurf.vel.mag().toFixed(2)} Angle: ${(windsurf.angle * 180/P5_TWO_PI).toFixed(0)}`,10,y); y+=dy;
            text(`SailTarget: ${(windsurf.targetSailAngle * 180/P5_TWO_PI).toFixed(0)} Cur: ${(windsurf.currentSailAngle * 180/P5_TWO_PI).toFixed(0)}`,10,y); y+=dy;
            text(`SailEff: ${windsurf.sailEfficiencyModifier.toFixed(2)}`,10,y);y+=dy;
            text(`FPS: ${frameRate().toFixed(1)}`, 10, y); y+=dy;
            text(`Touches: ${touches.length}`, 10, y); y+=dy;
            if(touchState.steer.active) text(`Steer ID: ${touchState.steer.id}`,10,y); y+=dy;
            if(touchState.efficiency.active) text(`Effic ID: ${touchState.efficiency.id}`,10,y); y+=dy;
        }
        
        function isTouchDevice() { return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0); }
        
        function handleTouchControls() {
            if (!isTouchDevice() || !windsurf) return;
            let effectiveDeltaTime = deltaTime / 16.66;

            if (touchState.steer.active) {
                let currentTouch = touches.find(t => t.id === touchState.steer.id);
                if (currentTouch) {
                    let dx = currentTouch.x - touchState.steer.startX;
                    windsurf.turn(constrain(dx * 0.007, -1, 1), effectiveDeltaTime);
                } else { 
                    touchState.steer.active = false; touchState.steer.id = -1;
                }
            }

            if (touchState.efficiency.active) {
                let currentTouch = touches.find(t => t.id === touchState.efficiency.id);
                if (currentTouch) {
                    let dy = currentTouch.y - touchState.efficiency.startY;
                    let efficiencyChange = -dy * 0.008 * effectiveDeltaTime; // Aumentata un po' la sensibilità
                    windsurf.sailEfficiencyModifier += efficiencyChange;
                    windsurf.sailEfficiencyModifier = constrain(windsurf.sailEfficiencyModifier, -1, 1);
                    touchState.efficiency.startY = currentTouch.y; 
                } else { 
                    touchState.efficiency.active = false; touchState.efficiency.id = -1;
                }
            }
        }

        function touchStarted(event) {
            if (!isTouchDevice() || !windsurf) return true;
            for (let touch of touches) {
                if (touch.x < width / 2 && !touchState.steer.active) {
                    touchState.steer.active = true;
                    touchState.steer.startX = touch.x;
                    touchState.steer.id = touch.id;
                } else if (touch.x >= width / 2 && !touchState.efficiency.active) {
                    touchState.efficiency.active = true;
                    touchState.efficiency.startY = touch.y;
                    touchState.efficiency.id = touch.id;
                }
            }
            return false;
        }

        function touchEnded(event) {
            if (!isTouchDevice()) return true;
            for (let endedTouch of event.changedTouches) {
                if (endedTouch.identifier === touchState.steer.id) {
                    touchState.steer.active = false; touchState.steer.id = -1;
                }
                if (endedTouch.identifier === touchState.efficiency.id) {
                    touchState.efficiency.active = false; touchState.efficiency.id = -1;
                }
            }
            if (touches.length === 0) {
                touchState.steer.active = false; touchState.steer.id = -1;
                touchState.efficiency.active = false; touchState.efficiency.id = -1;
            }
            return false;
        }
    </script>
</body>
</html>
