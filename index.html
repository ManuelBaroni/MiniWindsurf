<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Windsurf Adventure Fullscreen Corrected</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #000033;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
        }
        #controlsInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.65);
            padding: 5px;
            border-radius: 3px;
            z-index: 100;
            max-width: calc(100% - 20px);
            box-sizing: border-box;
        }
        #fullscreenButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            font-size: 14px;
            background-color: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.5);
            color: white;
            cursor: pointer;
            border-radius: 5px;
            z-index: 101;
        }
    </style>
</head>
<body>
    <button id="fullscreenButton">Fullscreen</button>
    <div id="controlsInfo"></div>
    <script>
        // --- CONFIGURAZIONI ---
        const WORLD_WIDTH = 12000;
        const WORLD_HEIGHT = 9000;
        const NUM_OCEAN_PARTICLES = 400;
        const SHOW_DEBUG_INFO = false;

        // --- VARIABILI GLOBALI ---
        let windsurf;
        let wind;
        let oceanParticles = [];
        let islands = [];
        let camera;
        let P5_TWO_PI;
        let fullscreenBtn;

        let touchState = {
            steer: { active: false, startX: 0, id: -1 },
            efficiency: { active: false, startY: 0, id: -1 } // Per controllo efficienza vela
        };

        // --- CLASSE CAMERA ---
        class Camera {
            constructor(x, y, followStrength = 0.08) {
                this.pos = createVector(x, y);
                this.target = null;
                this.followStrength = followStrength;
            }
            follow(target) { this.target = target; }
            update() {
                if (this.target) {
                    let effectiveDeltaTime = deltaTime / 16.66;
                    let targetX = this.target.pos.x - width / 2;
                    let targetY = this.target.pos.y - height / 2;
                    this.pos.x += (targetX - this.pos.x) * this.followStrength * effectiveDeltaTime;
                    this.pos.y += (targetY - this.pos.y) * this.followStrength * effectiveDeltaTime;
                    this.pos.x = constrain(this.pos.x, 0, WORLD_WIDTH - width);
                    this.pos.y = constrain(this.pos.y, 0, WORLD_HEIGHT - height);
                }
            }
            apply() { translate(-this.pos.x, -this.pos.y); }
        }

              // --- CLASSE WINDSURF (CON VELA CURVA DINAMICA) ---
        class Windsurf {
            constructor(x, y) {
                this.pos = createVector(x, y);
                this.vel = createVector(0, 0);
                this.angle = -P5_TWO_PI / 4;

                this.currentSailAngle = 0;
                this.targetSailAngle = 0;
                this.sailRotationSpeed = P5_TWO_PI * 0.35;

                this.boardWidth = 22;
                this.boardLength = 80;
                this.sailBoomLength = 55; // Lunghezza del boma
                this.sailMastHeight = 70; // Altezza dell'albero dalla base del boma al top
                this.mastOffset = -this.boardLength * 0.15;

                // Parametri per la curvatura della vela
                this.maxSailDepthFactor = 0.25; // Fattore massimo di "pancia" (es. 25% della lunghezza del boma)
                this.currentSailDepth = 0;    // "Pancia" attuale della vela

                this.maxSpeed = 7;
                this.turnRate = 0.04;
                this.friction = 0.02;
                this.lateralResistance = 0.92;
                this.baseAccelerationFactor = 0.08;
                this.isColliding = false;

                this.sailEfficiencyModifier = 0;
                this.sailEfficiencyChangeRate = 0.03;
            }

            // handleInput, turn, calculatePropulsionForRelativeSail, calculateOptimalRelativeSailAngle
            // rimangono IDENTICI alla versione precedente.

            handleInput() { /* ... identico ... */
                let effectiveDeltaTime = deltaTime / 16.66;
                if (keyIsDown(LEFT_ARROW)) this.turn(-1, effectiveDeltaTime);
                if (keyIsDown(RIGHT_ARROW)) this.turn(1, effectiveDeltaTime);
                let efficiencyChangedByKeyboard = false;
                if (keyIsDown(UP_ARROW) || keyIsDown(87)) { this.sailEfficiencyModifier += this.sailEfficiencyChangeRate * effectiveDeltaTime; efficiencyChangedByKeyboard = true; }
                else if (keyIsDown(DOWN_ARROW) || keyIsDown(83)) { this.sailEfficiencyModifier -= this.sailEfficiencyChangeRate * effectiveDeltaTime; efficiencyChangedByKeyboard = true; }
                if (!touchState.efficiency.active && !efficiencyChangedByKeyboard) {
                    if (abs(this.sailEfficiencyModifier) > 0.01) { this.sailEfficiencyModifier -= Math.sign(this.sailEfficiencyModifier) * this.sailEfficiencyChangeRate * 0.5 * effectiveDeltaTime; }
                    else { this.sailEfficiencyModifier = 0; }
                }
                this.sailEfficiencyModifier = constrain(this.sailEfficiencyModifier, -1, 1);
            }
            turn(direction, dt) { this.angle += this.turnRate * direction * dt; }
            calculatePropulsionForRelativeSail(boardAngle, relativeSailAngle, currentWindAngle, currentWindStrength) { /* ... identico ... */
                let sailGlobalAngle = boardAngle + relativeSailAngle;
                let windToSailNormalAngle = smallestAngleBetween(currentWindAngle, sailGlobalAngle + P5_TWO_PI / 4);
                let forceMagnitudeOnSail = currentWindStrength * cos(windToSailNormalAngle);
                let forceDirFromSail = sailGlobalAngle + P5_TWO_PI / 4;
                let angleBetweenForceAndBoard = smallestAngleBetween(forceDirFromSail, boardAngle);
                let propulsion = forceMagnitudeOnSail * cos(angleBetweenForceAndBoard);
                return propulsion;
            }
            calculateOptimalRelativeSailAngle(boardAngle, currentWindAngle, currentWindStrength) { /* ... identico ... */
                let bestRelativeAngle = 0; let maxPropulsion = -Infinity; let step = P5_TWO_PI / 72;
                for (let testRelAngle = -P5_TWO_PI / 2; testRelAngle <= P5_TWO_PI / 2; testRelAngle += step) {
                    let currentTestAngle = (testRelAngle % P5_TWO_PI + P5_TWO_PI) % P5_TWO_PI;
                    if (currentTestAngle > P5_TWO_PI / 2) currentTestAngle -= P5_TWO_PI;
                    let propulsion = this.calculatePropulsionForRelativeSail(boardAngle, currentTestAngle, currentWindAngle, currentWindStrength);
                    if (propulsion > maxPropulsion) { maxPropulsion = propulsion; bestRelativeAngle = currentTestAngle; }
                }
                return bestRelativeAngle;
            }


            update() {
                let effectiveDeltaTime = deltaTime / 16.66;

                this.targetSailAngle = this.calculateOptimalRelativeSailAngle(this.angle, wind.angle, wind.strength);
                let angleDiff = smallestAngleBetween(this.targetSailAngle, this.currentSailAngle);
                let maxRotationThisFrame = this.sailRotationSpeed * (deltaTime / 1000); 

                if (abs(angleDiff) <= maxRotationThisFrame) {
                    this.currentSailAngle = this.targetSailAngle;
                } else {
                    this.currentSailAngle += Math.sign(angleDiff) * maxRotationThisFrame;
                }
                this.currentSailAngle = (this.currentSailAngle % P5_TWO_PI + P5_TWO_PI) % P5_TWO_PI;
                if (this.currentSailAngle > P5_TWO_PI / 2) this.currentSailAngle -= P5_TWO_PI;

                // Calcolo della "pancia" della vela
                let sailGlobalAngle = this.angle + this.currentSailAngle;
                let windToSailAngle = smallestAngleBetween(wind.angle, sailGlobalAngle);
                // La pancia è massima quando il vento colpisce la vela di lato (vicino a +/- PI/2 rispetto all'angolo della vela)
                // e minima quando è di prua/poppa (vicino a 0 o PI)
                let pressureFactor = abs(sin(windToSailAngle)); // sin(0)=0, sin(PI/2)=1
                let targetSailDepth = this.maxSailDepthFactor * this.sailBoomLength * pressureFactor * wind.strength * 0.5; // Scalato anche per forza vento
                targetSailDepth = constrain(targetSailDepth, 0, this.maxSailDepthFactor * this.sailBoomLength);
                
                // Smussa il cambiamento della pancia
                this.currentSailDepth += (targetSailDepth - this.currentSailDepth) * 0.1 * effectiveDeltaTime;


                let rawSailPropulsion = this.calculatePropulsionForRelativeSail(this.angle, this.currentSailAngle, wind.angle, wind.strength);
                let effectiveAccelerationFactor = this.baseAccelerationFactor * (1 + this.sailEfficiencyModifier);
                effectiveAccelerationFactor = max(0, effectiveAccelerationFactor);
                
                let finalPropulsion = rawSailPropulsion;
                let boardDirection = p5.Vector.fromAngle(this.angle);
                let sailAcceleration = boardDirection.copy().mult(finalPropulsion * effectiveAccelerationFactor);
                this.vel.add(p5.Vector.mult(sailAcceleration, effectiveDeltaTime));

                // ... (resto di update: Attrito, Resistenza Laterale, Limita Velocità, Posizione, Bordi Mondo) ...
                // è IDENTICO alla versione precedente
                let frictionForce = this.vel.copy().mult(-this.friction);
                this.vel.add(p5.Vector.mult(frictionForce, effectiveDeltaTime));
                let perpendicularToBoard = p5.Vector.fromAngle(this.angle + P5_TWO_PI / 4);
                let lateralVelocityComponent = p5.Vector.dot(this.vel, perpendicularToBoard);
                let lateralDragForce = perpendicularToBoard.copy().mult(-lateralVelocityComponent * this.lateralResistance);
                this.vel.add(p5.Vector.mult(lateralDragForce, effectiveDeltaTime));
                if (this.vel.mag() > this.maxSpeed) this.vel.setMag(this.maxSpeed);
                if (!this.isColliding) { this.pos.add(p5.Vector.mult(this.vel, effectiveDeltaTime)); }
                else { this.vel.mult(0.3); }
                this.isColliding = false;
                if (this.pos.x < this.boardLength / 2) { this.pos.x = this.boardLength / 2; this.vel.x *= -0.3; }
                if (this.pos.x > WORLD_WIDTH - this.boardLength / 2) { this.pos.x = WORLD_WIDTH - this.boardLength / 2; this.vel.x *= -0.3; }
                if (this.pos.y < this.boardLength / 2) { this.pos.y = this.boardLength / 2; this.vel.y *= -0.3; }
                if (this.pos.y > WORLD_HEIGHT - this.boardLength / 2) { this.pos.y = WORLD_HEIGHT - this.boardLength / 2; this.vel.y *= -0.3; }

            }

            // checkCollision è invariata
            checkCollision(island) { /* ... identico ... */ 
                 for (const polygon of island.polygons) {
                    if (collidePointPoly(this.pos.x, this.pos.y, polygon)) {
                        this.isColliding = true;
                        let pushForce = createVector(0,0); let minDist = Infinity;
                        for (let i = 0; i < polygon.length; i++) {
                            let p1 = polygon[i]; let p2 = polygon[(i + 1) % polygon.length];
                            let closestPt = getClosestPointOnSegment(this.pos, p1, p2);
                            let distToSegment = p5.Vector.dist(this.pos, closestPt);
                            if (distToSegment < minDist) {
                                minDist = distToSegment;
                                let segmentVec = p5.Vector.sub(p2, p1);
                                let normal = createVector(-segmentVec.y, segmentVec.x).normalize();
                                if (p5.Vector.dot(normal, p5.Vector.sub(this.pos, closestPt)) < 0) normal.mult(-1);
                                pushForce = normal;
                            }
                        }
                        if (minDist < this.boardWidth / 1.5) {
                             this.pos.add(pushForce.mult((this.boardWidth / 1.5 - minDist) * 1.2));
                             this.vel.mult(0.1);
                        }
                        return true;
                    }
                }
                return false;
            }


            draw() {
                push();
                translate(this.pos.x, this.pos.y);
                rotate(this.angle); // Angolo della tavola

                // Disegno scia (identico)
                let speed = this.vel.mag();
                if (speed > 0.3) { /* ... */ 
                    stroke(255, 255, 255, map(speed, 0.3, this.maxSpeed, 20, 120));
                    let wakeWidth = map(speed, 0.3, this.maxSpeed, 1, this.boardWidth * 0.7);
                    let wakeLength = map(speed, 0.3, this.maxSpeed, 15, 90);
                    strokeWeight(wakeWidth * 0.5);
                    line(0, this.boardWidth * 0.25, -wakeLength, this.boardWidth * 0.35);
                    line(0, -this.boardWidth * 0.25, -wakeLength, -this.boardWidth * 0.35);
                    strokeWeight(wakeWidth);
                    line(0, 0, -wakeLength * 0.7, 0);
                }
                
                // Disegno tavola (identico)
                fill(200, 170, 110); stroke(80, 60, 40); strokeWeight(1.5);
                beginShape(); /* ... */ 
                vertex(-this.boardLength / 2, 0); 
                bezierVertex(-this.boardLength / 2 * 0.9, -this.boardWidth / 2 * 0.8, -this.boardLength / 3, -this.boardWidth / 2, 0, -this.boardWidth / 2);
                vertex(this.boardLength / 2 * 0.6, -this.boardWidth / 2 * 0.7); 
                bezierVertex(this.boardLength / 2 * 0.85, -this.boardWidth / 2 * 0.3, this.boardLength / 2, -this.boardWidth * 0.1, this.boardLength / 2, 0);
                bezierVertex(this.boardLength / 2, this.boardWidth * 0.1, this.boardLength / 2 * 0.85, this.boardWidth / 2 * 0.3, this.boardLength / 2 * 0.6, this.boardWidth / 2 * 0.7);
                vertex(0, this.boardWidth / 2);
                bezierVertex(-this.boardLength / 3, this.boardWidth / 2, -this.boardLength / 2 * 0.9, this.boardWidth / 2 * 0.8, -this.boardLength / 2, 0);
                endShape(CLOSE);
                fill(180,150,100, 150); noStroke(); ellipse(-this.boardLength*0.35, 0, 10, this.boardWidth*0.6);
                fill(60,60,60); rect(this.mastOffset - 8, -3, 16, 6, 2);


                translate(this.mastOffset, 0); // Sposta all'albero
                fill(50, 50, 60); ellipse(0, 0, 10, 10); // Albero

                rotate(this.currentSailAngle); // USA L'ANGOLO ATTUALE SMUSSATO

                // --- NUOVO DISEGNO VELA CURVA ---
                fill(235, 235, 250, 190 + sin(frameCount * 0.05 + this.pos.x * 0.005 + this.pos.y * 0.003) * 35);
                stroke(50, 50, 70); strokeWeight(1.5);

                // Punti chiave della vela
                let mastTopY = -this.sailMastHeight;    // Y del top dell'albero (relativo alla base del boma)
                let mastBaseY = 0;                      // Y della base del boma (all'albero)
                let boomEndX = this.sailBoomLength;     // X della fine del boma
                let boomEndY = 0;                       // Y della fine del boma (attacco bugna)

                // Punti di controllo per la curvatura (pancia)
                // La pancia è perpendicolare al boma.
                // La direzione della pancia dipende da currentSailAngle:
                // se la vela è a sinistra della tavola (angolo negativo), la pancia va "sotto" (Y positivo)
                // se la vela è a destra (angolo positivo), la pancia va "sopra" (Y negativo)
                // Tuttavia, la pancia dovrebbe sempre essere "sottovento" rispetto alla direzione del vento apparente sulla vela.
                // Per semplicità, la facciamo curvare sempre dalla stessa parte rispetto al boma,
                // e l'illusione della direzione del vento sarà data dall'angolo globale della vela.
                // Un approccio più realistico considererebbe il lato del vento.
                // Per ora, facciamo la pancia "verso Y negativo" (se vista localmente)
                
                let sailDepthSign = -1; // Default: pancia "in alto"
                // Se l'angolo della vela è molto girato (>90 gradi o < -90 gradi relativi alla tavola),
                // la pancia potrebbe dover invertire per sembrare corretta rispetto al flusso del vento.
                // Questo è complesso. Per ora, teniamo un segno fisso e vediamo l'effetto.
                // Se currentSailAngle è tra -PI/2 e PI/2, la pancia è tipicamente da un lato.
                // Se è oltre, l'altro lato diventa sopravvento.
                // In alternativa, la pancia è sempre "lontana" dal vento.
                // Angolo globale della vela: this.angle + this.currentSailAngle
                // Angolo del vento: wind.angle
                // Se il vento viene da "sinistra" della vela (globalmente), la pancia è a "destra"
                // Se (wind.angle - (this.angle + this.currentSailAngle)) normalizzato è tra 0 e PI, pancia a destra (negativo Y locale)
                // Altrimenti pancia a sinistra (positivo Y locale)
                let globalSailAngle = this.angle + this.currentSailAngle;
                let windRelativeToGlobalSail = smallestAngleBetween(wind.angle, globalSailAngle);

                if (windRelativeToGlobalSail > 0 && windRelativeToGlobalSail < PI) { // Vento da sinistra della vela
                    sailDepthSign = 1; // Pancia "in basso" (Y positivo locale)
                } else if (windRelativeToGlobalSail < 0 && windRelativeToGlobalSail > -PI) { // Vento da destra della vela
                    sailDepthSign = -1; // Pancia "in alto" (Y negativo locale)
                } else { // Vento perfettamente da prua o poppa della vela
                    // In questo caso la pancia potrebbe essere minima o ambigua, usiamo il default
                    sailDepthSign = (this.currentSailAngle >=0 ) ? -1 : 1; // Semplice fallback
                }


                let luffControlX = this.sailBoomLength * 0.15; // Punto di controllo per l'inferitura (luff)
                let luffControlY = mastTopY * 0.6 + sailDepthSign * this.currentSailDepth * 0.3; // Curva verso la pancia
                
                let leechControlX = this.sailBoomLength * 0.75; // Punto di controllo per la balumina (leech)
                let leechControlY = mastTopY * 0.4 + sailDepthSign * this.currentSailDepth * 0.6;

                let footControlX = this.sailBoomLength * 0.5;   // Punto di controllo per la base (foot)
                let footControlY = sailDepthSign * this.currentSailDepth; // Massima pancia qui

                beginShape();
                // Inferitura (Luff - dal top dell'albero alla base del boma)
                vertex(0, mastTopY); // Top albero
                quadraticVertex(luffControlX, luffControlY, 0, mastBaseY); // Curva verso la base del boma

                // Base (Foot - lungo il boma, con pancia)
                // vertex(0, mastBaseY); // Già qui dal luff
                quadraticVertex(footControlX, footControlY, boomEndX, boomEndY); // Curva fino alla bugna

                // Balumina (Leech - dalla bugna al top dell'albero)
                // vertex(boomEndX, boomEndY); // Già qui dal foot
                quadraticVertex(leechControlX, leechControlY, 0, mastTopY); // Curva fino al top albero
                endShape(CLOSE);

                // Disegna il boma sopra la vela per chiarezza
                stroke(70, 70, 80); strokeWeight(5); noFill();
                beginShape();
                vertex(0,0); // Attacco albero
                // Punto di controllo per la curva del boma (leggermente curvo)
                quadraticVertex(this.sailBoomLength * 0.6, sailDepthSign * this.currentSailDepth * 0.1, this.sailBoomLength, 0);
                endShape();
                // --- FINE NUOVO DISEGNO VELA ---
                
                pop(); // Fine trasformazioni windsurf
            }
            getSpeed() { return this.vel.mag(); }
        }

        // --- CLASSE ISOLA ---
        class Island { 
            constructor(x, y, size, seed) {
                this.pos = createVector(x, y); this.size = size; this.seed = seed || random(10000);
                this.polygons = [];
                this.color = color(random(100,140), random(150,190), random(60,100));
                this.beachColor = color(random(210,240), random(190,220), random(150,180));
                this.generateShape();
            }
            generateShape() {
                let islandVerts = []; let numVertices = int(random(7, 15)); noiseSeed(this.seed);
                for (let i = 0; i < numVertices; i++) {
                    let angle = map(i, 0, numVertices, 0, P5_TWO_PI);
                    let r = this.size * (0.6 + 0.8 * noise(cos(angle) * 2 + 10, sin(angle) * 2 + 20, this.seed * 0.01));
                    islandVerts.push(createVector(this.pos.x + r * cos(angle), this.pos.y + r * sin(angle)));
                }
                this.polygons.push(islandVerts);
            }
            draw() {
                for (const polygon of this.polygons) {
                    strokeWeight(this.size * 0.20); stroke(this.beachColor); noFill();
                    beginShape(); for (let v of polygon) curveVertex(v.x, v.y);
                    if (polygon.length > 2) { curveVertex(polygon[0].x, polygon[0].y); curveVertex(polygon[1].x, polygon[1].y); curveVertex(polygon[2].x, polygon[2].y); }
                    endShape();
                    fill(this.color); noStroke();
                    beginShape(); for (let v of polygon) vertex(v.x, v.y); endShape(CLOSE);
                    if (this.size > 100) {
                        for(let i=0; i< polygon.length; i+=2) {
                            if(random() < 0.3) {
                                let v = polygon[i];
                                let treeOffsetX = (noise(v.x*0.1, v.y*0.1, this.seed+100)-0.5) * this.size * 0.2;
                                let treeOffsetY = (noise(v.x*0.1, v.y*0.1, this.seed+200)-0.5) * this.size * 0.2;
                                let treeX = v.x + treeOffsetX; let treeY = v.y + treeOffsetY;
                                if (collidePointPoly(treeX, treeY, polygon)) {
                                    fill(50, random(80,120), 30); ellipse(treeX, treeY, this.size*0.08, this.size*0.12);
                                    fill(80,60,40); rect(treeX-this.size*0.01, treeY+this.size*0.05, this.size*0.02, this.size*0.05);
                                } } } } } }
        }

        function updateWind() {
             if (!wind) return;
            let effectiveDeltaTime = deltaTime / 16.66;
            let da = smallestAngleBetween(wind.targetAngle, wind.angle);
            wind.angle += da * wind.variability * effectiveDeltaTime; 
            wind.angle = (wind.angle % P5_TWO_PI + P5_TWO_PI) % P5_TWO_PI;
            
            if (abs(da) < 0.01 || random(1) < 0.0005 * effectiveDeltaTime) {
                 wind.targetAngle = wind.angle + random(-P5_TWO_PI/5, P5_TWO_PI/5);
                 wind.targetAngle = (wind.targetAngle % P5_TWO_PI + P5_TWO_PI) % P5_TWO_PI;
            }
            let ds = wind.targetStrength - wind.strength;
            wind.strength += ds * wind.strengthVariability * effectiveDeltaTime;
            if (abs(ds) < 0.05 || random(1) < 0.001 * effectiveDeltaTime) {
                wind.targetStrength = constrain(random(0.7, 3.2), 0.5, 3.5);
            }
        }
        function smallestAngleBetween(target, source) {
            let a = (target - source) % P5_TWO_PI;
            return a > P5_TWO_PI / 2 ? a - P5_TWO_PI : (a < -P5_TWO_PI / 2 ? a + P5_TWO_PI : a);
        }
        function getClosestPointOnSegment(p, a, b) {
            let ap = p5.Vector.sub(p, a); let ab = p5.Vector.sub(b, a);
            let abMagSq = ab.magSq(); if (abMagSq === 0) return a.copy();
            let t = constrain(p5.Vector.dot(ap, ab) / abMagSq, 0, 1);
            return p5.Vector.add(a, ab.mult(t));
        }
        function collidePointPoly(px, py, vertices) {
            var collision = false; var next = 0;
            for (var current = 0; current < vertices.length; current++) {
                next = current + 1; if (next == vertices.length) next = 0;
                var vc = vertices[current]; var vn = vertices[next];
                if (((vc.y > py && vn.y < py) || (vc.y < py && vn.y > py)) &&
                    (px < (vn.x - vc.x) * (py - vc.y) / (vn.y - vc.y) + vc.x)) {
                    collision = !collision;
                }
            }
            return collision;
        }

       function setup() {
            let canvas = createCanvas(windowWidth, windowHeight); // Coerente con windowResized
            canvas.parent(document.body);
            pixelDensity(1);
            
            P5_TWO_PI = TWO_PI;
            if (typeof P5_TWO_PI === 'undefined') P5_TWO_PI = 2 * Math.PI;

            wind = { angle: random(P5_TWO_PI), strength: 1.5, targetAngle: random(P5_TWO_PI), targetStrength: 1.5, variability: 0.001, strengthVariability: 0.0005 };
            windsurf = new Windsurf(WORLD_WIDTH / 2, WORLD_HEIGHT / 2);
            camera = new Camera(windsurf.pos.x - width/2, windsurf.pos.y - height/2); camera.follow(windsurf);
            let numIslands = 60;
            for (let i = 0; i < numIslands; i++) {
                let islandX = random(WORLD_WIDTH * 0.02, WORLD_WIDTH * 0.98); let islandY = random(WORLD_HEIGHT * 0.02, WORLD_HEIGHT * 0.98);
                let islandSize = random(120, 600);
                if (dist(islandX, islandY, windsurf.pos.x, windsurf.pos.y) > max(islandSize, 300) + 300) { islands.push(new Island(islandX, islandY, islandSize, i * 123.456)); } else { i--; }
            }
            for (let i = 0; i < NUM_OCEAN_PARTICLES; i++) { oceanParticles.push({ x: random(WORLD_WIDTH), y: random(WORLD_HEIGHT), size: random(0.5, 2.5), opacity: random(15, 50), speedFactor: random(0.05, 0.25) }); }
            
            updateWind();
            updateControlsInfo();

            fullscreenBtn = document.getElementById('fullscreenButton');
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', toggleFullScreen);
                if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled && !document.mozFullScreenEnabled && !document.msFullscreenEnabled) {
                    fullscreenBtn.style.display = 'none';
                }
            }
            windowResized(); // Chiamata iniziale per assicurare dimensioni corrette
        }
        function toggleFullScreen() {
            let elem = document.documentElement;
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                if (elem.requestFullscreen) elem.requestFullscreen();
                else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
                else if (elem.mozRequestFullScreen) elem.mozRequestFullScreen();
                else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
            }
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight); // Coerente con setup
            updateControlsInfo();
            if (camera) {
                 camera.pos.x = constrain(camera.pos.x, 0, WORLD_WIDTH - width);
                 camera.pos.y = constrain(camera.pos.y, 0, WORLD_HEIGHT - height);
            }
        }

        document.addEventListener('fullscreenchange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.fullscreenElement ? "Exit" : "Fullscreen"; });
        document.addEventListener('webkitfullscreenchange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.webkitFullscreenElement ? "Exit" : "Fullscreen"; });
        document.addEventListener('mozfullscreenchange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.mozFullScreenElement ? "Exit" : "Fullscreen"; });
        document.addEventListener('MSFullscreenChange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.msFullscreenElement ? "Exit" : "Fullscreen"; });
        
        function draw() {
            if (!wind || !windsurf) { background(0); fill(255); textSize(20); textAlign(CENTER,CENTER); text("Loading...", width/2, height/2); return; }
            background(30, 60, 130);
            windsurf.handleInput(); handleTouchControls(); // handleTouchControls ora gestisce efficienza
            updateWind(); windsurf.update(); camera.update();
            for (let island of islands) { if (dist(windsurf.pos.x, windsurf.pos.y, island.pos.x, island.pos.y) < island.size + windsurf.boardLength * 1.5) windsurf.checkCollision(island); }
            push(); camera.apply(); drawOceanSurface();
            for (let island of islands) { if (island.pos.x + island.size > camera.pos.x && island.pos.x - island.size < camera.pos.x + width && island.pos.y + island.size > camera.pos.y && island.pos.y - island.size < camera.pos.y + height) island.draw(); }
            windsurf.draw(); pop();
            drawWindIndicator(); drawSpeedometer(); drawSailAngleIndicator(); drawMiniMap();
            if (SHOW_DEBUG_INFO) drawDebugInfo();
        }

        let waveOffset = 0;
        function drawOceanSurface() {
            stroke(180, 200, 230); let effectiveDeltaTime = deltaTime / 16.66;
            for (let p of oceanParticles) {
                strokeWeight(p.size); fill(180,200,230, p.opacity);
                p.x += cos(wind.angle) * wind.strength * p.speedFactor * 0.1 * effectiveDeltaTime;
                p.y += sin(wind.angle) * wind.strength * p.speedFactor * 0.1 * effectiveDeltaTime;
                p.x = (p.x % WORLD_WIDTH + WORLD_WIDTH) % WORLD_WIDTH; p.y = (p.y % WORLD_HEIGHT + WORLD_HEIGHT) % WORLD_HEIGHT;
                if (p.x > camera.pos.x - 10 && p.x < camera.pos.x + width + 10 && p.y > camera.pos.y - 10 && p.y < camera.pos.y + height + 10) ellipse(p.x, p.y, p.size, p.size);
            }
            let waveDetail = 30; let numWaves = ceil(max(width, height) / waveDetail) + 10; waveOffset += wind.strength * 0.03 * effectiveDeltaTime;
            strokeWeight(1 + wind.strength * 0.3); noFill(); let waveAngle = wind.angle + P5_TWO_PI/4;
            let screenCenterXWorld = camera.pos.x + width/2; let screenCenterYWorld = camera.pos.y + height/2;
            for (let i = -numWaves / 2; i < numWaves / 2; i++) {
                stroke(130, 160, 220, 40 + wind.strength * 15 + sin(i*0.3 + waveOffset*2)*15);
                let lineBaseDist = i * waveDetail + (waveOffset*20 % waveDetail);
                let x0 = screenCenterXWorld + cos(waveAngle) * lineBaseDist - sin(waveAngle) * (width*1.5); let y0 = screenCenterYWorld + sin(waveAngle) * lineBaseDist + cos(waveAngle) * (width*1.5);
                let x1 = screenCenterXWorld + cos(waveAngle) * lineBaseDist + sin(waveAngle) * (width*1.5); let y1 = screenCenterYWorld + sin(waveAngle) * lineBaseDist - cos(waveAngle) * (width*1.5);
                beginShape(); let segments = 30;
                for(let j=0; j<=segments; j++) {
                    let t = j/segments; let x = lerp(x0, x1, t); let y = lerp(y0, y1, t);
                    let noiseX = (x * cos(wind.angle) + y * sin(wind.angle)) * 0.015; let noiseY = (-x * sin(wind.angle) + y * cos(wind.angle)) * 0.008;
                    let noiseVal = noise(noiseX + waveOffset * 0.3, noiseY + i * 0.1);
                    let amplitude = (5 + wind.strength * 3) * (0.5 + noiseVal * 1.5);
                    let vx = x + sin(waveAngle) * amplitude; let vy = y - cos(waveAngle) * amplitude; curveVertex(vx, vy);
                } endShape(); }
        }
        
        function drawWindIndicator() {
            const isSmallScreen = min(width, height) < 600;
            let R = min(width, height) * (isSmallScreen ? 0.065 : 0.045);
            let margin = min(width, height) * (isSmallScreen ? 0.04 : 0.025);
            let cx = width - R - margin; let cy = R + margin;
            push(); translate(cx, cy); fill(255, 255, 255, 90); noStroke(); ellipse(0,0, R*2, R*2);
            stroke(255,255,255,120); strokeWeight(max(1.2, R*0.025));
            for(let a=0; a<P5_TWO_PI; a+=P5_TWO_PI/16) line(0,0, cos(a)*R, sin(a)*R);
            line(0,-R,0,R); line(-R,0,R,0); rotate(wind.angle);
            let arrowLen = R * 0.8 + wind.strength * (R * 0.08);
            stroke(255,50,50); strokeWeight(max(2, R*0.08 + wind.strength * 0.6)); line(0,0, arrowLen,0);
            fill(255,50,50); noStroke(); triangle(arrowLen,0, arrowLen-R*0.25,-R*0.12, arrowLen-R*0.25,R*0.12); pop();
            fill(255); textSize(max(10, R*0.35)); textAlign(CENTER,CENTER);
            text(wind.strength.toFixed(1) + " kn", cx, cy + R + margin*0.6); text("VENTO", cx, cy - R - margin*0.6);
        }

        function drawSpeedometer() {
            const isSmallScreen = min(width, height) < 600;
            let R = min(width, height) * (isSmallScreen ? 0.075 : 0.055);
            let margin = min(width, height) * (isSmallScreen ? 0.04 : 0.025);
            let cx = R + margin; let cy = height - R - margin;
            push(); translate(cx, cy); noFill(); stroke(255,255,255,120); strokeWeight(max(4, R*0.22));
            arc(0,0, R*2, R*2, P5_TWO_PI * 0.375, P5_TWO_PI * 0.125);
            let speed = windsurf.getSpeed();
            let speedAngle = map(speed, 0, windsurf.maxSpeed, P5_TWO_PI * 0.375, P5_TWO_PI * 0.125);
            stroke(120,220,255); strokeWeight(max(3, R*0.18));
            arc(0,0, R*2, R*2, P5_TWO_PI * 0.375, speedAngle);
            rotate(speedAngle); stroke(255); strokeWeight(max(1.5, R*0.06)); line(0,0,R*0.9,0); pop();
            fill(255); textSize(max(12, R*0.4)); textAlign(CENTER,CENTER);
            text(speed.toFixed(1), cx, cy); textSize(max(9, R*0.28)); text("m/s", cx, cy + R*0.5 + margin*0.4);
        }

        function drawSailAngleIndicator() {
            const isSmallScreen = min(width, height) < 600;
            let ROuterSpeedo = min(width, height) * (isSmallScreen ? 0.075 : 0.055);
            let marginSpeedo = min(width, height) * (isSmallScreen ? 0.04 : 0.025);
            let speedoTopY = height - ROuterSpeedo - marginSpeedo - ROuterSpeedo;
            let R = min(width, height) * (isSmallScreen ? 0.055 : 0.04);
            let margin = min(width, height) * (isSmallScreen ? 0.03 : 0.020);
            let cx = ROuterSpeedo + marginSpeedo; let cy = speedoTopY - R - margin;
            push(); translate(cx, cy); fill(200,170,110,120); noStroke();
            rect(-R*0.2, -R*0.8, R*0.4, R*1.6, R*0.12);
            rotate(windsurf.currentSailAngle); // Usa currentSailAngle
            fill(230,230,250,180); stroke(50); strokeWeight(max(1.2, R*0.05));
            beginShape(); vertex(0,0); vertex(R*1.2, R*0.2); vertex(R*1.1, -R*0.2); endShape(CLOSE); pop();
            fill(255); textSize(max(9, R*0.28)); textAlign(CENTER,CENTER);
            text("VELA", cx, cy + R + margin*0.6);
        }

        function drawMiniMap() {
            const isSmallScreen = min(width, height) < 600;
            let mapSize = min(width, height) * (isSmallScreen ? 0.22 : 0.16);
            let margin = min(width, height) * (isSmallScreen ? 0.035 : 0.025);
            let mapX, mapY;
            if (isSmallScreen) {
                let windIndicatorRadius = min(width, height) * 0.065;
                let windIndicatorMargin = min(width, height) * 0.04;
                let windIndicatorBottom = windIndicatorRadius * 2 + windIndicatorMargin * 2;
                mapX = margin; mapY = windIndicatorBottom + margin;
                if (mapY + mapSize > height - margin) mapY = margin;
            } else {
                mapX = width - mapSize - margin; mapY = height - mapSize - margin;
            }
            let sX = mapSize / WORLD_WIDTH; let sY = mapSize / WORLD_HEIGHT;
            push(); translate(mapX, mapY);
            fill(0, 40, 90, 150); noStroke(); rect(0,0, mapSize, mapSize, max(3, mapSize*0.04));
            for (let island of islands) { fill(island.color); beginShape(); for (let v of island.polygons[0]) vertex(v.x * sX, v.y * sY); endShape(CLOSE); }
            fill(255,0,0); ellipse(windsurf.pos.x*sX, windsurf.pos.y*sY, max(2.5, mapSize*0.02), max(2.5, mapSize*0.02));
            noFill(); stroke(255,255,255,100); strokeWeight(max(1.2, mapSize*0.006));
            rect(camera.pos.x*sX, camera.pos.y*sY, width*sX, height*sY); pop();
        }
        
        function updateControlsInfo() {
            let info = "<b>Controlli Tastiera:</b><br>";
            info += "FRECCE Sx/Dx: Vira<br>";
            info += "FRECCIA SU / W: Aumenta Efficienza Vela<br>";
            info += "FRECCIA GIU / S: Riduci Efficienza Vela<br><br>";
            let controlDiv = document.getElementById('controlsInfo');
            if (isTouchDevice()) {
                info += "<b>Controlli Touch:</b><br>";
                info += "Trascina Metà Sx: Vira<br>";
                info += "Trascina Metà Dx (Vert.): Efficienza Vela"; // Aggiornato
                controlDiv.style.fontSize = "10px";
                controlDiv.style.padding = "3px";
            } else {
                controlDiv.style.fontSize = "12px";
                controlDiv.style.padding = "5px";
            }
            controlDiv.innerHTML = info;
        }
        
        function drawDebugInfo() {
             fill(255);textSize(12);textAlign(LEFT,TOP); let y = 10; const dy = 15;
            text(`Pos: ${windsurf.pos.x.toFixed(0)}, ${windsurf.pos.y.toFixed(0)}`, 10, y); y+=dy;
            text(`Vel: ${windsurf.vel.mag().toFixed(2)} Angle: ${(windsurf.angle * 180/P5_TWO_PI).toFixed(0)}`,10,y); y+=dy;
            text(`SailTarget: ${(windsurf.targetSailAngle * 180/P5_TWO_PI).toFixed(0)} Cur: ${(windsurf.currentSailAngle * 180/P5_TWO_PI).toFixed(0)}`,10,y); y+=dy;
            text(`SailEff: ${windsurf.sailEfficiencyModifier.toFixed(2)}`,10,y);y+=dy;
            text(`FPS: ${frameRate().toFixed(1)}`, 10, y); y+=dy;
            text(`Touches: ${touches.length}`, 10, y); y+=dy;
            if(touchState.steer.active) text(`Steer ID: ${touchState.steer.id}`,10,y); y+=dy;
            if(touchState.efficiency.active) text(`Effic ID: ${touchState.efficiency.id}`,10,y); y+=dy;
        }
        
        function isTouchDevice() { return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0); }
        
        function handleTouchControls() {
            if (!isTouchDevice() || !windsurf) return;
            let effectiveDeltaTime = deltaTime / 16.66;

            if (touchState.steer.active) {
                let currentTouch = touches.find(t => t.id === touchState.steer.id);
                if (currentTouch) {
                    let dx = currentTouch.x - touchState.steer.startX;
                    windsurf.turn(constrain(dx * 0.007, -1, 1), effectiveDeltaTime);
                } else { 
                    touchState.steer.active = false; touchState.steer.id = -1;
                }
            }

            if (touchState.efficiency.active) {
                let currentTouch = touches.find(t => t.id === touchState.efficiency.id);
                if (currentTouch) {
                    let dy = currentTouch.y - touchState.efficiency.startY;
                    let efficiencyChange = -dy * 0.008 * effectiveDeltaTime; // Aumentata un po' la sensibilità
                    windsurf.sailEfficiencyModifier += efficiencyChange;
                    windsurf.sailEfficiencyModifier = constrain(windsurf.sailEfficiencyModifier, -1, 1);
                    touchState.efficiency.startY = currentTouch.y; 
                } else { 
                    touchState.efficiency.active = false; touchState.efficiency.id = -1;
                }
            }
        }

        function touchStarted(event) {
            if (!isTouchDevice() || !windsurf) return true;
            for (let touch of touches) {
                if (touch.x < width / 2 && !touchState.steer.active) {
                    touchState.steer.active = true;
                    touchState.steer.startX = touch.x;
                    touchState.steer.id = touch.id;
                } else if (touch.x >= width / 2 && !touchState.efficiency.active) {
                    touchState.efficiency.active = true;
                    touchState.efficiency.startY = touch.y;
                    touchState.efficiency.id = touch.id;
                }
            }
            return false;
        }

        function touchEnded(event) {
            if (!isTouchDevice()) return true;
            for (let endedTouch of event.changedTouches) {
                if (endedTouch.identifier === touchState.steer.id) {
                    touchState.steer.active = false; touchState.steer.id = -1;
                }
                if (endedTouch.identifier === touchState.efficiency.id) {
                    touchState.efficiency.active = false; touchState.efficiency.id = -1;
                }
            }
            if (touches.length === 0) {
                touchState.steer.active = false; touchState.steer.id = -1;
                touchState.efficiency.active = false; touchState.efficiency.id = -1;
            }
            return false;
        }
    </script>
</body>
</html>
