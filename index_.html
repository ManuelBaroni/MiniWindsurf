<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Windsurf Adventure Corrected</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #000033;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
        }
        #controlsInfo {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.65);
            padding: 5px;
            border-radius: 3px;
            z-index: 100;
            max-width: calc(100% - 20px);
            box-sizing: border-box;
        }
        #fullscreenButton {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            font-size: 14px;
            background-color: rgba(255,255,255,0.3);
            border: 1px solid rgba(255,255,255,0.5);
            color: white;
            cursor: pointer;
            border-radius: 5px;
            z-index: 101;
        }
    </style>
</head>
<body>
    <button id="fullscreenButton">Fullscreen</button>
    <div id="controlsInfo"></div>
    <script>
        // --- CONFIGURAZIONI ---
        const WORLD_WIDTH = 12000;
        const WORLD_HEIGHT = 9000;
        const NUM_OCEAN_PARTICLES = 400;
        const SHOW_DEBUG_INFO = false; // Imposta su true per vedere info di debug

        // --- VARIABILI GLOBALI ---
        let windsurf;
        let wind;
        let oceanParticles = [];
        let islands = [];
        let camera;
        let P5_TWO_PI;
        let fullscreenBtn;

        let touchState = {
            steer: { active: false, startX: 0, id: -1 },
            efficiency: { active: false, startY: 0, id: -1 }
        };

        // --- CLASSE CAMERA ---
        class Camera {
            constructor(x, y, followStrength = 0.08) {
                this.pos = createVector(x, y);
                this.target = null;
                this.followStrength = followStrength;
            }
            follow(target) { this.target = target; }
            update() {
                if (this.target) {
                    let effectiveDeltaTime = deltaTime / 16.66;
                    let targetX = this.target.pos.x - width / 2;
                    let targetY = this.target.pos.y - height / 2;
                    this.pos.x += (targetX - this.pos.x) * this.followStrength * effectiveDeltaTime;
                    this.pos.y += (targetY - this.pos.y) * this.followStrength * effectiveDeltaTime;
                    this.pos.x = constrain(this.pos.x, 0, WORLD_WIDTH - width);
                    this.pos.y = constrain(this.pos.y, 0, WORLD_HEIGHT - height);
                }
            }
            apply() { translate(-this.pos.x, -this.pos.y); }
        }
        
        // --- CLASSE WINDSURF (CON VELA FLUIDA E LOGICA POSIZIONAMENTO MIGLIORATA) ---
        class Windsurf {
            constructor(x, y) {
                this.pos = createVector(x, y);
                this.vel = createVector(0, 0);
                this.angle = -P5_TWO_PI / 4; // Angolo della tavola

                this.currentSailAngle = 0;    // Angolo RELATIVO attuale della "base" vela rispetto alla tavola
                this.targetSailAngle = 0;
                this.sailRotationSpeed = P5_TWO_PI * 0.45; // Più reattiva

                this.boardWidth = 22;
                this.boardLength = 80;
                this.sailBaseLength = 60; // Lunghezza del "boma" o base della vela
                this.maxSailArchDepth = this.sailBaseLength * 0.35; // Massima "pancia"
                this.currentSailArchDepth = 0; // "Pancia" attuale, per animazione

                this.mastAttachmentPointX = -this.boardLength * 0.10; // Punto di attacco vela sulla tavola

                this.maxSpeed = 7;
                this.turnRate = 0.04;
                this.friction = 0.02;
                this.lateralResistance = 0.92;
                this.baseAccelerationFactor = 0.08;
                this.isColliding = false;

                this.sailEfficiencyModifier = 0; // Da -1 (meno efficiente) a +1 (più efficiente)
                this.sailEfficiencyChangeRate = 0.03;
            }

            handleInput() {
                let effectiveDeltaTime = deltaTime / 16.66;
                if (keyIsDown(LEFT_ARROW)) this.turn(-1, effectiveDeltaTime);
                if (keyIsDown(RIGHT_ARROW)) this.turn(1, effectiveDeltaTime);

                let efficiencyChangedByKeyboard = false;
                if (keyIsDown(UP_ARROW) || keyIsDown(87)) { // W
                    this.sailEfficiencyModifier += this.sailEfficiencyChangeRate * effectiveDeltaTime;
                    efficiencyChangedByKeyboard = true;
                } else if (keyIsDown(DOWN_ARROW) || keyIsDown(83)) { // S
                    this.sailEfficiencyModifier -= this.sailEfficiencyChangeRate * effectiveDeltaTime;
                    efficiencyChangedByKeyboard = true;
                }
                
                // Se l'efficienza non è controllata attivamente dal touch né dalla tastiera, falla tornare a 0
                if (!touchState.efficiency.active && !efficiencyChangedByKeyboard) {
                    if (abs(this.sailEfficiencyModifier) > 0.015) { // Soglia leggermente più alta per evitare micro-aggiustamenti
                        this.sailEfficiencyModifier -= Math.sign(this.sailEfficiencyModifier) * this.sailEfficiencyChangeRate * 0.7 * effectiveDeltaTime; // Ritorno più veloce
                    } else {
                        this.sailEfficiencyModifier = 0;
                    }
                }
                this.sailEfficiencyModifier = constrain(this.sailEfficiencyModifier, -1, 1);
            }

            turn(direction, dt) { this.angle += this.turnRate * direction * dt; }

            calculatePropulsionForRelativeSail(boardAngle, relativeSailAngle, currentWindAngle, currentWindStrength) {
                let sailGlobalAngle = boardAngle + relativeSailAngle;
                let windToSailNormalAngle = smallestAngleBetween(currentWindAngle, sailGlobalAngle + P5_TWO_PI / 4);
                let forceMagnitudeOnSail = currentWindStrength * cos(windToSailNormalAngle);
                let forceDirFromSail = sailGlobalAngle + P5_TWO_PI / 4;
                let angleBetweenForceAndBoard = smallestAngleBetween(forceDirFromSail, boardAngle);
                let propulsion = forceMagnitudeOnSail * cos(angleBetweenForceAndBoard);
                return propulsion;
            }
            
            calculateOptimalRelativeSailAngle(boardAngle, currentWindAngle, currentWindStrength) {
                let windAngleRelativeToBoard = smallestAngleBetween(currentWindAngle, boardAngle);
                let optimalRelativeSailAngle = 0;
                const deadZoneAngle = P5_TWO_PI * 0.12; // ~43 gradi

                if (abs(windAngleRelativeToBoard) < deadZoneAngle) { // Controvento
                    optimalRelativeSailAngle = -windAngleRelativeToBoard * 0.8; // Tende ad allinearsi, sbattendo
                } else { // Altre andature
                    let bestAngleFound = 0;
                    let maxPropulsion = -Infinity;
                    let step = P5_TWO_PI / 72; // ~5 gradi

                    for (let testRelAngle = -P5_TWO_PI / 2 + 0.01; testRelAngle < P5_TWO_PI / 2 - 0.01; testRelAngle += step) {
                        let prop = this.calculatePropulsionForRelativeSail(boardAngle, testRelAngle, currentWindAngle, currentWindStrength);
                        if (prop > maxPropulsion) {
                            maxPropulsion = prop;
                            bestAngleFound = testRelAngle;
                        }
                    }
                    optimalRelativeSailAngle = bestAngleFound;
                }
                return constrain(optimalRelativeSailAngle, -P5_TWO_PI/2 * 0.98, P5_TWO_PI/2 * 0.98);
            }

            update() {
                let effectiveDeltaTime = deltaTime / 16.66;

                this.targetSailAngle = this.calculateOptimalRelativeSailAngle(this.angle, wind.angle, wind.strength);
                let angleDiff = smallestAngleBetween(this.targetSailAngle, this.currentSailAngle);
                let maxRotationThisFrame = this.sailRotationSpeed * (deltaTime / 1000); 
                if (abs(angleDiff) <= maxRotationThisFrame) { this.currentSailAngle = this.targetSailAngle; }
                else { this.currentSailAngle += Math.sign(angleDiff) * maxRotationThisFrame; }
                this.currentSailAngle = (this.currentSailAngle % P5_TWO_PI + P5_TWO_PI) % P5_TWO_PI;
                if (this.currentSailAngle > P5_TWO_PI / 2) this.currentSailAngle -= P5_TWO_PI;

                let sailGlobalAngle = this.angle + this.currentSailAngle;
                let windToSailAxisNormal = smallestAngleBetween(wind.angle, sailGlobalAngle + P5_TWO_PI / 4);
                let pressureFactor = cos(windToSailAxisNormal); 
                pressureFactor = max(0, pressureFactor);
                let windAngleRelativeToBoard = smallestAngleBetween(wind.angle, this.angle);
                const deadZoneAngle = P5_TWO_PI * 0.12;
                if (abs(windAngleRelativeToBoard) < deadZoneAngle) {
                    pressureFactor = 0.1 + sin(frameCount * 0.3 + this.pos.x * 0.01) * 0.05; // Leggero sbattimento
                }
                let targetSailArchDepth = this.maxSailArchDepth * pressureFactor * (wind.strength / 1.5) * (1 + this.sailEfficiencyModifier * 0.5); // Efficienza influenza anche pancia
                targetSailArchDepth = constrain(targetSailArchDepth, 0, this.maxSailArchDepth);
                this.currentSailArchDepth += (targetSailArchDepth - this.currentSailArchDepth) * 0.20 * effectiveDeltaTime;

                let rawSailPropulsion = this.calculatePropulsionForRelativeSail(this.angle, this.currentSailAngle, wind.angle, wind.strength);
                if (abs(windAngleRelativeToBoard) < deadZoneAngle) {
                    rawSailPropulsion = min(0, rawSailPropulsion) - 0.005 * wind.strength * cos(windAngleRelativeToBoard); // Piccola resistenza controvento
                }

                let effectiveAccelerationFactor = this.baseAccelerationFactor * (1 + this.sailEfficiencyModifier);
                effectiveAccelerationFactor = max(0, effectiveAccelerationFactor);
                let finalPropulsion = rawSailPropulsion;
                let boardDirection = p5.Vector.fromAngle(this.angle);
                let sailAcceleration = boardDirection.copy().mult(finalPropulsion * effectiveAccelerationFactor);
                this.vel.add(p5.Vector.mult(sailAcceleration, effectiveDeltaTime));

                let frictionForce = this.vel.copy().mult(-this.friction);
                this.vel.add(p5.Vector.mult(frictionForce, effectiveDeltaTime));
                let perpendicularToBoard = p5.Vector.fromAngle(this.angle + P5_TWO_PI / 4);
                let lateralVelocityComponent = p5.Vector.dot(this.vel, perpendicularToBoard);
                let lateralDragForce = perpendicularToBoard.copy().mult(-lateralVelocityComponent * this.lateralResistance);
                this.vel.add(p5.Vector.mult(lateralDragForce, effectiveDeltaTime));
                if (this.vel.mag() > this.maxSpeed) this.vel.setMag(this.maxSpeed);
                if (abs(windAngleRelativeToBoard) < deadZoneAngle && this.vel.mag() < 0.05 && this.sailEfficiencyModifier <= 0) {
                    this.vel.set(0,0);
                }
                if (!this.isColliding) { this.pos.add(p5.Vector.mult(this.vel, effectiveDeltaTime)); }
                else { this.vel.mult(0.3); }
                this.isColliding = false;
                if (this.pos.x < this.boardLength / 2) { this.pos.x = this.boardLength / 2; this.vel.x *= -0.3; }
                if (this.pos.x > WORLD_WIDTH - this.boardLength / 2) { this.pos.x = WORLD_WIDTH - this.boardLength / 2; this.vel.x *= -0.3; }
                if (this.pos.y < this.boardLength / 2) { this.pos.y = this.boardLength / 2; this.vel.y *= -0.3; }
                if (this.pos.y > WORLD_HEIGHT - this.boardLength / 2) { this.pos.y = WORLD_HEIGHT - this.boardLength / 2; this.vel.y *= -0.3; }
            }

            checkCollision(island) {
                for (const polygon of island.polygons) {
                    if (collidePointPoly(this.pos.x, this.pos.y, polygon)) {
                        this.isColliding = true;
                        let pushForce = createVector(0,0); let minDist = Infinity;
                        for (let i = 0; i < polygon.length; i++) {
                            let p1 = polygon[i]; let p2 = polygon[(i + 1) % polygon.length];
                            let closestPt = getClosestPointOnSegment(this.pos, p1, p2);
                            let distToSegment = p5.Vector.dist(this.pos, closestPt);
                            if (distToSegment < minDist) {
                                minDist = distToSegment;
                                let segmentVec = p5.Vector.sub(p2, p1);
                                let normal = createVector(-segmentVec.y, segmentVec.x).normalize();
                                if (p5.Vector.dot(normal, p5.Vector.sub(this.pos, closestPt)) < 0) normal.mult(-1);
                                pushForce = normal;
                            }
                        }
                        if (minDist < this.boardWidth / 1.5) {
                             this.pos.add(pushForce.mult((this.boardWidth / 1.5 - minDist) * 1.2));
                             this.vel.mult(0.1);
                        }
                        return true;
                    }
                }
                return false;
            }
            
            draw() {
                push();
                translate(this.pos.x, this.pos.y);
                rotate(this.angle);

                let speed = this.vel.mag();
                if (speed > 0.3) {
                    stroke(255, 255, 255, map(speed, 0.3, this.maxSpeed, 20, 120));
                    let wakeWidth = map(speed, 0.3, this.maxSpeed, 1, this.boardWidth * 0.7);
                    let wakeLength = map(speed, 0.3, this.maxSpeed, 15, 90);
                    strokeWeight(wakeWidth * 0.5);
                    line(0, this.boardWidth * 0.25, -wakeLength, this.boardWidth * 0.35);
                    line(0, -this.boardWidth * 0.25, -wakeLength, -this.boardWidth * 0.35);
                    strokeWeight(wakeWidth);
                    line(0, 0, -wakeLength * 0.7, 0);
                }
                
                fill(200, 170, 110); stroke(80, 60, 40); strokeWeight(1.5);
                beginShape();
                vertex(-this.boardLength / 2, 0); 
                bezierVertex(-this.boardLength / 2 * 0.9, -this.boardWidth / 2 * 0.8, -this.boardLength / 3, -this.boardWidth / 2, 0, -this.boardWidth / 2);
                vertex(this.boardLength / 2 * 0.6, -this.boardWidth / 2 * 0.7); 
                bezierVertex(this.boardLength / 2 * 0.85, -this.boardWidth / 2 * 0.3, this.boardLength / 2, -this.boardWidth * 0.1, this.boardLength / 2, 0);
                bezierVertex(this.boardLength / 2, this.boardWidth * 0.1, this.boardLength / 2 * 0.85, this.boardWidth / 2 * 0.3, this.boardLength / 2 * 0.6, this.boardWidth / 2 * 0.7);
                vertex(0, this.boardWidth / 2);
                bezierVertex(-this.boardLength / 3, this.boardWidth / 2, -this.boardLength / 2 * 0.9, this.boardWidth / 2 * 0.8, -this.boardLength / 2, 0);
                endShape(CLOSE);
                fill(180,150,100, 150); noStroke(); ellipse(-this.boardLength*0.35, 0, 10, this.boardWidth*0.6);

                push();
                translate(this.mastAttachmentPointX, 0);
                rotate(this.currentSailAngle);

                fill(230, 230, 240, 200); stroke(40, 40, 60); strokeWeight(1.5);
                let p1x = 0, p1y = 0;
                let p3x = this.sailBaseLength, p3y = 0;
                let controlX = this.sailBaseLength / 2;
                // Assicura che l'arco sia sempre "fuori" dalla tavola a meno che non sia a 0 gradi relativi
                let archSign = (this.currentSailAngle >= 0 && this.currentSailAngle < PI) ? -1 : 1; // Semplificato
                if (abs(this.currentSailAngle) < 0.01) archSign = -1; // Per 0 gradi, falla andare "sopra"
                let controlY = archSign * this.currentSailArchDepth;

                beginShape();
                vertex(p1x, p1y); 
                quadraticVertex(controlX, controlY, p3x, p3y); 
                // Aggiungi un secondo quadraticVertex per chiudere l'arco e dare spessore visivo
                quadraticVertex(controlX, controlY * 0.95, p1x, p1y); // Leggermente dentro per effetto
                endShape(CLOSE); 
                pop(); 
                
                pop();
            }
            getSpeed() { return this.vel.mag(); }
        }
        
        // --- CLASSE ISOLA ---
        class Island { 
            constructor(x, y, size, seed) {
                this.pos = createVector(x, y); this.size = size; this.seed = seed || random(10000);
                this.polygons = [];
                this.color = color(random(100,140), random(150,190), random(60,100));
                this.beachColor = color(random(210,240), random(190,220), random(150,180));
                this.generateShape();
            }
            generateShape() {
                let islandVerts = []; let numVertices = int(random(7, 15)); noiseSeed(this.seed);
                for (let i = 0; i < numVertices; i++) {
                    let angle = map(i, 0, numVertices, 0, P5_TWO_PI);
                    let r = this.size * (0.6 + 0.8 * noise(cos(angle) * 2 + 10, sin(angle) * 2 + 20, this.seed * 0.01));
                    islandVerts.push(createVector(this.pos.x + r * cos(angle), this.pos.y + r * sin(angle)));
                }
                this.polygons.push(islandVerts);
            }
            draw() {
                for (const polygon of this.polygons) {
                    strokeWeight(this.size * 0.20); stroke(this.beachColor); noFill();
                    beginShape(); for (let v of polygon) curveVertex(v.x, v.y);
                    if (polygon.length > 2) { curveVertex(polygon[0].x, polygon[0].y); curveVertex(polygon[1].x, polygon[1].y); curveVertex(polygon[2].x, polygon[2].y); }
                    endShape();
                    fill(this.color); noStroke();
                    beginShape(); for (let v of polygon) vertex(v.x, v.y); endShape(CLOSE);
                    if (this.size > 100) {
                        for(let i=0; i< polygon.length; i+=2) {
                            if(random() < 0.3) {
                                let v = polygon[i];
                                let treeOffsetX = (noise(v.x*0.1, v.y*0.1, this.seed+100)-0.5) * this.size * 0.2;
                                let treeOffsetY = (noise(v.x*0.1, v.y*0.1, this.seed+200)-0.5) * this.size * 0.2;
                                let treeX = v.x + treeOffsetX; let treeY = v.y + treeOffsetY;
                                if (collidePointPoly(treeX, treeY, polygon)) {
                                    fill(50, random(80,120), 30); ellipse(treeX, treeY, this.size*0.08, this.size*0.12);
                                    fill(80,60,40); rect(treeX-this.size*0.01, treeY+this.size*0.05, this.size*0.02, this.size*0.05);
                                } } } } } }
        }

        function updateWind() {
             if (!wind) return;
            let effectiveDeltaTime = deltaTime / 16.66;
            let da = smallestAngleBetween(wind.targetAngle, wind.angle);
            wind.angle += da * wind.variability * effectiveDeltaTime; 
            wind.angle = (wind.angle % P5_TWO_PI + P5_TWO_PI) % P5_TWO_PI;
            
            if (abs(da) < 0.01 || random(1) < 0.0005 * effectiveDeltaTime) {
                 wind.targetAngle = wind.angle + random(-P5_TWO_PI/5, P5_TWO_PI/5);
                 wind.targetAngle = (wind.targetAngle % P5_TWO_PI + P5_TWO_PI) % P5_TWO_PI;
            }
            let ds = wind.targetStrength - wind.strength;
            wind.strength += ds * wind.strengthVariability * effectiveDeltaTime;
            if (abs(ds) < 0.05 || random(1) < 0.001 * effectiveDeltaTime) {
                wind.targetStrength = constrain(random(0.7, 3.2), 0.5, 3.5);
            }
        }
        function smallestAngleBetween(target, source) {
            let a = (target - source) % P5_TWO_PI;
            return a > P5_TWO_PI / 2 ? a - P5_TWO_PI : (a < -P5_TWO_PI / 2 ? a + P5_TWO_PI : a);
        }
        function getClosestPointOnSegment(p, a, b) {
            let ap = p5.Vector.sub(p, a); let ab = p5.Vector.sub(b, a);
            let abMagSq = ab.magSq(); if (abMagSq === 0) return a.copy();
            let t = constrain(p5.Vector.dot(ap, ab) / abMagSq, 0, 1);
            return p5.Vector.add(a, ab.mult(t));
        }
        function collidePointPoly(px, py, vertices) {
            var collision = false; var next = 0;
            for (var current = 0; current < vertices.length; current++) {
                next = current + 1; if (next == vertices.length) next = 0;
                var vc = vertices[current]; var vn = vertices[next];
                if (((vc.y > py && vn.y < py) || (vc.y < py && vn.y > py)) &&
                    (px < (vn.x - vc.x) * (py - vc.y) / (vn.y - vc.y) + vc.x)) {
                    collision = !collision;
                }
            }
            return collision;
        }

       function setup() {
            let canvas = createCanvas(windowWidth, windowHeight);
            canvas.parent(document.body);
            pixelDensity(1);
            
            P5_TWO_PI = TWO_PI;
            if (typeof P5_TWO_PI === 'undefined') P5_TWO_PI = 2 * Math.PI;

            wind = { angle: random(P5_TWO_PI), strength: 1.5, targetAngle: random(P5_TWO_PI), targetStrength: 1.5, variability: 0.001, strengthVariability: 0.0005 };
            windsurf = new Windsurf(WORLD_WIDTH / 2, WORLD_HEIGHT / 2);
            camera = new Camera(windsurf.pos.x - width/2, windsurf.pos.y - height/2); camera.follow(windsurf);
            let numIslands = 60;
            for (let i = 0; i < numIslands; i++) {
                let islandX = random(WORLD_WIDTH * 0.02, WORLD_WIDTH * 0.98); let islandY = random(WORLD_HEIGHT * 0.02, WORLD_HEIGHT * 0.98);
                let islandSize = random(120, 600);
                if (dist(islandX, islandY, windsurf.pos.x, windsurf.pos.y) > max(islandSize, 300) + 300) { islands.push(new Island(islandX, islandY, islandSize, i * 123.456)); } else { i--; }
            }
            for (let i = 0; i < NUM_OCEAN_PARTICLES; i++) { oceanParticles.push({ x: random(WORLD_WIDTH), y: random(WORLD_HEIGHT), size: random(0.5, 2.5), opacity: random(15, 50), speedFactor: random(0.05, 0.25) }); }
            
            updateWind();
            updateControlsInfo();

            fullscreenBtn = document.getElementById('fullscreenButton');
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', toggleFullScreen);
                if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled && !document.mozFullScreenEnabled && !document.msFullscreenEnabled) {
                    fullscreenBtn.style.display = 'none';
                }
            }
            windowResized();
        }
        function toggleFullScreen() {
            let elem = document.documentElement;
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                if (elem.requestFullscreen) elem.requestFullscreen();
                else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
                else if (elem.mozRequestFullScreen) elem.mozRequestFullScreen();
                else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                else if (document.msExitFullscreen) document.msExitFullscreen();
            }
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            updateControlsInfo();
            if (camera) {
                 camera.pos.x = constrain(camera.pos.x, 0, WORLD_WIDTH - width);
                 camera.pos.y = constrain(camera.pos.y, 0, WORLD_HEIGHT - height);
            }
        }

        document.addEventListener('fullscreenchange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.fullscreenElement ? "Exit" : "Fullscreen"; });
        document.addEventListener('webkitfullscreenchange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.webkitFullscreenElement ? "Exit" : "Fullscreen"; });
        document.addEventListener('mozfullscreenchange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.mozFullScreenElement ? "Exit" : "Fullscreen"; });
        document.addEventListener('MSFullscreenChange', () => { if(fullscreenBtn) fullscreenBtn.textContent = document.msFullscreenElement ? "Exit" : "Fullscreen"; });
        
        function draw() {
            if (!wind || !windsurf) { background(0); fill(255); textSize(20); textAlign(CENTER,CENTER); text("Loading...", width/2, height/2); return; }
            background(30, 60, 130);
            windsurf.handleInput(); handleTouchControls();
            updateWind(); windsurf.update(); camera.update();
            for (let island of islands) { if (dist(windsurf.pos.x, windsurf.pos.y, island.pos.x, island.pos.y) < island.size + windsurf.boardLength * 1.5) windsurf.checkCollision(island); }
            push(); camera.apply(); drawOceanSurface();
            for (let island of islands) { if (island.pos.x + island.size > camera.pos.x && island.pos.x - island.size < camera.pos.x + width && island.pos.y + island.size > camera.pos.y && island.pos.y - island.size < camera.pos.y + height) island.draw(); }
            windsurf.draw(); pop();
            drawWindIndicator(); drawSpeedometer(); drawSailAngleIndicator(); drawMiniMap();
            if (SHOW_DEBUG_INFO) drawDebugInfo();
        }

        let waveOffset = 0;
        function drawOceanSurface() {
            stroke(180, 200, 230); let effectiveDeltaTime = deltaTime / 16.66;
            for (let p of oceanParticles) {
                strokeWeight(p.size); fill(180,200,230, p.opacity);
                p.x += cos(wind.angle) * wind.strength * p.speedFactor * 0.1 * effectiveDeltaTime;
                p.y += sin(wind.angle) * wind.strength * p.speedFactor * 0.1 * effectiveDeltaTime;
                p.x = (p.x % WORLD_WIDTH + WORLD_WIDTH) % WORLD_WIDTH; p.y = (p.y % WORLD_HEIGHT + WORLD_HEIGHT) % WORLD_HEIGHT;
                if (p.x > camera.pos.x - 10 && p.x < camera.pos.x + width + 10 && p.y > camera.pos.y - 10 && p.y < camera.pos.y + height + 10) ellipse(p.x, p.y, p.size, p.size);
            }
            let waveDetail = 30; let numWaves = ceil(max(width, height) / waveDetail) + 10; waveOffset += wind.strength * 0.03 * effectiveDeltaTime;
            strokeWeight(1 + wind.strength * 0.3); noFill(); let waveAngle = wind.angle + P5_TWO_PI/4;
            let screenCenterXWorld = camera.pos.x + width/2; let screenCenterYWorld = camera.pos.y + height/2;
            for (let i = -numWaves / 2; i < numWaves / 2; i++) {
                stroke(130, 160, 220, 40 + wind.strength * 15 + sin(i*0.3 + waveOffset*2)*15);
                let lineBaseDist = i * waveDetail + (waveOffset*20 % waveDetail);
                let x0 = screenCenterXWorld + cos(waveAngle) * lineBaseDist - sin(waveAngle) * (width*1.5); let y0 = screenCenterYWorld + sin(waveAngle) * lineBaseDist + cos(waveAngle) * (width*1.5);
                let x1 = screenCenterXWorld + cos(waveAngle) * lineBaseDist + sin(waveAngle) * (width*1.5); let y1 = screenCenterYWorld + sin(waveAngle) * lineBaseDist - cos(waveAngle) * (width*1.5);
                beginShape(); let segments = 30;
                for(let j=0; j<=segments; j++) {
                    let t = j/segments; let x = lerp(x0, x1, t); let y = lerp(y0, y1, t);
                    let noiseX = (x * cos(wind.angle) + y * sin(wind.angle)) * 0.015; let noiseY = (-x * sin(wind.angle) + y * cos(wind.angle)) * 0.008;
                    let noiseVal = noise(noiseX + waveOffset * 0.3, noiseY + i * 0.1);
                    let amplitude = (5 + wind.strength * 3) * (0.5 + noiseVal * 1.5);
                    let vx = x + sin(waveAngle) * amplitude; let vy = y - cos(waveAngle) * amplitude; curveVertex(vx, vy);
                } endShape(); }
        }
        
        function drawWindIndicator() {
            const isSmallScreen = min(width, height) < 600;
            let R = min(width, height) * (isSmallScreen ? 0.065 : 0.045);
            let margin = min(width, height) * (isSmallScreen ? 0.04 : 0.025);
            let cx = width - R - margin; let cy = R + margin;
            push(); translate(cx, cy); fill(255, 255, 255, 90); noStroke(); ellipse(0,0, R*2, R*2);
            stroke(255,255,255,120); strokeWeight(max(1.2, R*0.025));
            for(let a=0; a<P5_TWO_PI; a+=P5_TWO_PI/16) line(0,0, cos(a)*R, sin(a)*R);
            line(0,-R,0,R); line(-R,0,R,0); rotate(wind.angle);
            let arrowLen = R * 0.8 + wind.strength * (R * 0.08);
            stroke(255,50,50); strokeWeight(max(2, R*0.08 + wind.strength * 0.6)); line(0,0, arrowLen,0);
            fill(255,50,50); noStroke(); triangle(arrowLen,0, arrowLen-R*0.25,-R*0.12, arrowLen-R*0.25,R*0.12); pop();
            fill(255); textSize(max(10, R*0.35)); textAlign(CENTER,CENTER);
            text(wind.strength.toFixed(1) + " kn", cx, cy + R + margin*0.6); text("VENTO", cx, cy - R - margin*0.6);
        }

        function drawSpeedometer() {
            const isSmallScreen = min(width, height) < 600;
            let R = min(width, height) * (isSmallScreen ? 0.075 : 0.055);
            let margin = min(width, height) * (isSmallScreen ? 0.04 : 0.025);
            let cx = R + margin; let cy = height - R - margin;
            push(); translate(cx, cy); noFill(); stroke(255,255,255,120); strokeWeight(max(4, R*0.22));
            arc(0,0, R*2, R*2, P5_TWO_PI * 0.375, P5_TWO_PI * 0.125);
            let speed = windsurf.getSpeed();
            let speedAngle = map(speed, 0, windsurf.maxSpeed, P5_TWO_PI * 0.375, P5_TWO_PI * 0.125);
            stroke(120,220,255); strokeWeight(max(3, R*0.18));
            arc(0,0, R*2, R*2, P5_TWO_PI * 0.375, speedAngle);
            rotate(speedAngle); stroke(255); strokeWeight(max(1.5, R*0.06)); line(0,0,R*0.9,0); pop();
            fill(255); textSize(max(12, R*0.4)); textAlign(CENTER,CENTER);
            text(speed.toFixed(1), cx, cy); textSize(max(9, R*0.28)); text("m/s", cx, cy + R*0.5 + margin*0.4);
        }

        function drawSailAngleIndicator() {
            const isSmallScreen = min(width, height) < 600;
            let ROuterSpeedo = min(width, height) * (isSmallScreen ? 0.075 : 0.055);
            let marginSpeedo = min(width, height) * (isSmallScreen ? 0.04 : 0.025);
            let speedoTopY = height - ROuterSpeedo - marginSpeedo - ROuterSpeedo;
            let R = min(width, height) * (isSmallScreen ? 0.055 : 0.04);
            let margin = min(width, height) * (isSmallScreen ? 0.03 : 0.020);
            let cx = ROuterSpeedo + marginSpeedo; let cy = speedoTopY - R - margin;
            
            if (!windsurf) return; // Aggiunto controllo per evitare errori se windsurf non è pronto

            push(); translate(cx, cy); fill(200,170,110,120); noStroke();
            rect(-R*0.2, -R*0.8, R*0.4, R*1.6, R*0.12);
            
            // Usa windsurf.currentSailAngle per l'indicatore visivo
            rotate(windsurf.currentSailAngle); 

            fill(230,230,250,180); stroke(50); strokeWeight(max(1.2, R*0.05));
            // Semplificato il disegno della vela dell'indicatore a un triangolo,
            // dato che la forma ad arco precisa non è essenziale qui e può essere complessa da scalare
            beginShape();
            vertex(0,0); // Punto di attacco
            vertex(R * 1.2, R * 0.15); // Estremità del boma
            vertex(R * 1.2, -R * 0.15); // Altra estremità
            endShape(CLOSE);
            pop();

            fill(255); textSize(max(9, R*0.28)); textAlign(CENTER,CENTER);
            text("VELA", cx, cy + R + margin*0.6);
        }

        function drawMiniMap() {
            const isSmallScreen = min(width, height) < 600;
            let mapSize = min(width, height) * (isSmallScreen ? 0.22 : 0.16);
            let margin = min(width, height) * (isSmallScreen ? 0.035 : 0.025);
            let mapX, mapY;
            if (isSmallScreen) {
                let windIndicatorRadius = min(width, height) * 0.065;
                let windIndicatorMargin = min(width, height) * 0.04;
                let windIndicatorBottom = windIndicatorRadius * 2 + windIndicatorMargin * 2;
                mapX = margin; mapY = windIndicatorBottom + margin;
                if (mapY + mapSize > height - margin - (min(width,height)*0.1)) { // Aggiunto un po' di spazio extra per non sovrapporre troppo
                    mapY = margin; // Se non c'è spazio sotto l'indicatore del vento, mettila in alto
                }
            } else { // Schermi più grandi
                mapX = width - mapSize - margin; mapY = height - mapSize - margin;
            }
            let sX = mapSize / WORLD_WIDTH; let sY = mapSize / WORLD_HEIGHT;
            push(); translate(mapX, mapY);
            fill(0, 40, 90, 150); noStroke(); rect(0,0, mapSize, mapSize, max(3, mapSize*0.04));
            for (let island of islands) { fill(island.color); beginShape(); for (let v of island.polygons[0]) vertex(v.x * sX, v.y * sY); endShape(CLOSE); }
            fill(255,0,0); ellipse(windsurf.pos.x*sX, windsurf.pos.y*sY, max(2.5, mapSize*0.02), max(2.5, mapSize*0.02));
            noFill(); stroke(255,255,255,100); strokeWeight(max(1.2, mapSize*0.006));
            rect(camera.pos.x*sX, camera.pos.y*sY, width*sX, height*sY); pop();
        }
        
        function updateControlsInfo() {
            let info = "<b>Controlli Tastiera:</b><br>";
            info += "FRECCE Sx/Dx: Vira<br>";
            info += "FRECCIA SU / W: Aumenta Efficienza Vela<br>";
            info += "FRECCIA GIU / S: Riduci Efficienza Vela<br><br>";
            let controlDiv = document.getElementById('controlsInfo');
            if (isTouchDevice()) {
                info += "<b>Controlli Touch:</b><br>";
                info += "Trascina Metà Sx: Vira<br>";
                info += "Trascina Metà Dx (Vert.): Efficienza Vela";
                controlDiv.style.fontSize = "10px";
                controlDiv.style.padding = "3px";
            } else {
                controlDiv.style.fontSize = "12px";
                controlDiv.style.padding = "5px";
            }
            controlDiv.innerHTML = info;
        }
        
        function drawDebugInfo() {
             fill(255);textSize(12);textAlign(LEFT,TOP); let y = 10; const dy = 15;
            text(`Pos: ${windsurf.pos.x.toFixed(0)}, ${windsurf.pos.y.toFixed(0)}`, 10, y); y+=dy;
            text(`Vel: ${windsurf.vel.mag().toFixed(2)} Angle: ${(windsurf.angle * 180/P5_TWO_PI).toFixed(0)}`,10,y); y+=dy;
            text(`SailTarget: ${(windsurf.targetSailAngle * 180/P5_TWO_PI).toFixed(0)} Cur: ${(windsurf.currentSailAngle * 180/P5_TWO_PI).toFixed(0)}`,10,y); y+=dy;
            text(`SailEff: ${windsurf.sailEfficiencyModifier.toFixed(2)} Arch: ${windsurf.currentSailArchDepth.toFixed(2)}`,10,y);y+=dy;
            text(`FPS: ${frameRate().toFixed(1)}`, 10, y); y+=dy;
            text(`Touches: ${touches.length}`, 10, y); y+=dy;
            if(touchState.steer.active) text(`Steer ID: ${touchState.steer.id}`,10,y); y+=dy;
            if(touchState.efficiency.active) text(`Effic ID: ${touchState.efficiency.id}`,10,y); y+=dy;
        }
        
        function isTouchDevice() { return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0); }
        
        function handleTouchControls() {
            if (!isTouchDevice() || !windsurf) return;
            let effectiveDeltaTime = deltaTime / 16.66;

            if (touchState.steer.active) {
                let currentTouch = touches.find(t => t.id === touchState.steer.id);
                if (currentTouch) {
                    let dx = currentTouch.x - touchState.steer.startX;
                    windsurf.turn(constrain(dx * 0.007, -1, 1), effectiveDeltaTime);
                } else { 
                    touchState.steer.active = false; touchState.steer.id = -1;
                }
            }

            if (touchState.efficiency.active) {
                let currentTouch = touches.find(t => t.id === touchState.efficiency.id);
                if (currentTouch) {
                    let dy = currentTouch.y - touchState.efficiency.startY;
                    let efficiencyChange = -dy * 0.008 * effectiveDeltaTime;
                    windsurf.sailEfficiencyModifier += efficiencyChange;
                    windsurf.sailEfficiencyModifier = constrain(windsurf.sailEfficiencyModifier, -1, 1);
                    touchState.efficiency.startY = currentTouch.y; 
                } else { 
                    touchState.efficiency.active = false; touchState.efficiency.id = -1;
                }
            }
        }

        function touchStarted(event) {
            if (!isTouchDevice() || !windsurf) return true;
            for (let touch of touches) {
                if (touch.x < width / 2 && !touchState.steer.active) {
                    touchState.steer.active = true;
                    touchState.steer.startX = touch.x;
                    touchState.steer.id = touch.id;
                } else if (touch.x >= width / 2 && !touchState.efficiency.active) {
                    touchState.efficiency.active = true;
                    touchState.efficiency.startY = touch.y;
                    touchState.efficiency.id = touch.id;
                }
            }
            // Previene il comportamento di default solo se un controllo è stato attivato
            if (touchState.steer.active || touchState.efficiency.active) {
                return false;
            }
            return true;
        }

        function touchEnded(event) {
            if (!isTouchDevice()) return true;
            let controlWasActive = false;
            for (let endedTouch of event.changedTouches) {
                if (endedTouch.identifier === touchState.steer.id) {
                    touchState.steer.active = false; touchState.steer.id = -1;
                    controlWasActive = true;
                }
                if (endedTouch.identifier === touchState.efficiency.id) {
                    touchState.efficiency.active = false; touchState.efficiency.id = -1;
                    controlWasActive = true;
                }
            }
            if (touches.length === 0) { // Se nessun tocco rimane, resetta tutto
                touchState.steer.active = false; touchState.steer.id = -1;
                touchState.efficiency.active = false; touchState.efficiency.id = -1;
            }
             if (controlWasActive) {
                return false; // Previene il default se un controllo del gioco è stato rilasciato
            }
            return true;
        }
    </script>
</body>
</html>
